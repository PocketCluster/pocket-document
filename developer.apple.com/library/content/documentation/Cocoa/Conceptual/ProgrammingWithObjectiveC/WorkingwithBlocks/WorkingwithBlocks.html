<!DOCTYPE html>
<html lang="en">
<head>
    <title>Working with Blocks</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40011210">
    <meta id="document-version" name="document-version" content="2.7.1">
    <meta id="build" name="build" content="ded95564c405529dbbbe590063edd114" />
    <meta id="chapterId" name="chapterId" content="TP40011210-CH8">
    <meta id="date" name="date" content="2014-09-17">
    <meta id="description" name="description" content="Describes elements of best practice when writing code with Objective-C using ARC.">
    <meta id="book-title" name="book-title" content="Programming with Objective-C">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="Mac Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/mac">
    <meta id="reflib" name="reflib" content="Guides and Sample Code">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Languages & Utilities/Objective-C}">
    
    
    <meta id="copyright" name="copyright" content="Copyright 2017 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Programming with Objective-C: Working with Blocks">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1260">
    <link id="book-index-page" rel="Start" title="Programming with Objective-C" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../ErrorHandling/ErrorHandling.html">
    <link id="previous-page" rel="Prev" type="text/html" href="../FoundationTypesandCollections/FoundationTypesandCollections.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/feedback.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta id="platforms" name="platforms" content="">
</head>    
<body><a name="//apple_ref/doc/uid/TP40011210-CH8" title="Working with Blocks"></a>
    <div id="_omniture_top">
    <!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
    <script type="text/javascript">
    /* RSID: */
    var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
    </script>

    <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
    <script type="text/javascript">
    s.pageName=AC.Tracking.pageName();
    s.channel="www.us.developer"

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)</script>
    <!-- End SiteCatalyst code version: H.8. -->
    </div>

    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode unified">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>Guides and Sample Code</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search Guides and Sample Code</label>
            
            
    
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Programming with Objective-C</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../ErrorHandling/ErrorHandling.html'>Next</a><a class='previousLink' rel='prev' href='../FoundationTypesandCollections/FoundationTypesandCollections.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/TP40011210-CH8-SW1" title="Working with Blocks"></a><h1 id="pageTitle">Working with Blocks</h1><p>An Objective-C class defines an object that combines data with related behavior. Sometimes, it makes sense just to represent a single task or unit of behavior, rather than a collection of methods.</p><p>Blocks are a language-level feature added to C, Objective-C and C++, which allow you to create distinct segments of code that can be passed around to methods or functions as if they were values. Blocks are Objective-C objects, which means they can be added to collections like <code>NSArray</code> or <code>NSDictionary</code>. They also have the ability to capture values from the enclosing scope, making them similar to <em>closures</em> or <em>lambdas</em> in other programming languages.</p><p>This chapter explains the syntax to declare and refer to blocks, and shows how to use blocks to simplify common tasks such as collection enumeration. For further information, see <em><a href="../../Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" data-renderer-version="1" target="_self">Blocks Programming Topics</a></em>.</p><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW2" title="Block Syntax"></a><h2 class="jump">Block Syntax</h2><p>The syntax to define a block literal uses the caret symbol (<code>^</code>), like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    ^{<span></span></pre></td></tr><tr><td scope="row"><pre>         NSLog(@"This is a block");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>As with function and method definitions, the braces indicate the start and end of the block. In this example, the block doesn’t return any value, and doesn’t take any arguments.</p><p>In the same way that you can use a function pointer to refer to a C function, you can declare a variable to keep track of a block, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    void (^simpleBlock)(void);<span></span></pre></td></tr></table></div><p>If you’re not used to dealing with C function pointers, the syntax may seem a little unusual. This example declares a variable called <code>simpleBlock</code> to refer to a block that takes no arguments and doesn’t return a value, which means the variable can be assigned the block literal shown above, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    simpleBlock = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"This is a block");<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>This is just like any other variable assignment, so the statement must be terminated by a semi-colon after the closing brace. You can also combine the variable declaration and assignment:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    void (^simpleBlock)(void) = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"This is a block");<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>Once you’ve declared and assigned a block variable, you can use it to invoke the block:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    simpleBlock();<span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40011210-CH8-SW10" title="Note"></a><p><strong>Note:</strong>&nbsp;If you attempt to invoke a block using an unassigned variable (a <code>nil</code> block variable), your app will crash.</p><p></p></aside></div><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW9" title="Blocks Take Arguments and Return Values"></a><h3 class="jump">Blocks Take Arguments and Return Values</h3><p>Blocks can also take arguments and return values just like methods and functions.</p><p>As an example, consider a variable to refer to a block that returns the result of multiplying two values:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    double (^multiplyTwoValues)(double, double);<span></span></pre></td></tr></table></div><p>The corresponding block literal might look like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    ^ (double firstValue, double secondValue) {<span></span></pre></td></tr><tr><td scope="row"><pre>        return firstValue * secondValue;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>The <code>firstValue</code> and <code>secondValue</code> are used to refer to the values supplied when the block is invoked, just like any function definition. In this example, the return type is inferred from the return statement inside the block.</p><p>If you prefer, you can make the return type explicit by specifying it between the caret and the argument list:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    ^ double (double firstValue, double secondValue) {<span></span></pre></td></tr><tr><td scope="row"><pre>        return firstValue * secondValue;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>Once you’ve declared and defined the block, you can invoke it just like you would a function:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    double (^multiplyTwoValues)(double, double) =<span></span></pre></td></tr><tr><td scope="row"><pre>                              ^(double firstValue, double secondValue) {<span></span></pre></td></tr><tr><td scope="row"><pre>                                  return firstValue * secondValue;<span></span></pre></td></tr><tr><td scope="row"><pre>                              };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    double result = multiplyTwoValues(2,4);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"The result is %f", result);<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW3" title="Blocks Can Capture Values from the Enclosing Scope"></a><h3 class="jump">Blocks Can Capture Values from the Enclosing Scope</h3><p>As well as containing executable code, a block also has the ability to capture state from its enclosing scope.</p><p>If you declare a block literal from within a method, for example, it’s possible to capture any of the values accessible within the scope of that method, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)testMethod {<span></span></pre></td></tr><tr><td scope="row"><pre>    int anInteger = 42;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    void (^testBlock)(void) = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Integer is: %i", anInteger);<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    testBlock();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In this example, <code>anInteger</code> is declared outside of the block, but the value is captured when the block is defined.</p><p>Only the value is captured, unless you specify otherwise. This means that if you change the external value of the variable between the time you define the block and the time it’s invoked, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    int anInteger = 42;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    void (^testBlock)(void) = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Integer is: %i", anInteger);<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    anInteger = 84;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    testBlock();<span></span></pre></td></tr></table></div><p>the value captured by the block is unaffected. This means that the log output would still show:</p><div class="codesample clear"><table><tr><td scope="row"><pre>Integer is: 42<span></span></pre></td></tr></table></div><p>It also means that the block cannot change the value of the original variable, or even the captured value (it’s captured as a <code>const</code> variable).</p><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW4" title="Use __block Variables to Share Storage"></a><h4 class="jump">Use __block Variables to Share Storage</h4><p>If you need to be able to change the value of a captured variable from within a block, you can use the <code>__block</code> storage type modifier on the original variable declaration. This means that the variable lives in storage that is shared between the lexical scope of the original variable and any blocks declared within that scope.</p><p>As an example, you might rewrite the previous example like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    __block int anInteger = 42;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    void (^testBlock)(void) = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Integer is: %i", anInteger);<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    anInteger = 84;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    testBlock();<span></span></pre></td></tr></table></div><p>Because <code>anInteger</code> is declared as a <code>__block</code> variable, its storage is shared with the block declaration. This means that the log output would now show:</p><div class="codesample clear"><table><tr><td scope="row"><pre>Integer is: 84<span></span></pre></td></tr></table></div><p>It also means that the block can modify the original value, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    __block int anInteger = 42;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    void (^testBlock)(void) = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Integer is: %i", anInteger);<span></span></pre></td></tr><tr><td scope="row"><pre>        anInteger = 100;<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    testBlock();<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Value of original variable is now: %i", anInteger);<span></span></pre></td></tr></table></div><p>This time, the output would show:</p><div class="codesample clear"><table><tr><td scope="row"><pre>Integer is: 42<span></span></pre></td></tr><tr><td scope="row"><pre>Value of original variable is now: 100<span></span></pre></td></tr></table></div></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW7" title="You Can Pass Blocks as Arguments to Methods or Functions"></a><h3 class="jump">You Can Pass Blocks as Arguments to Methods or Functions</h3><p>Each of the previous examples in this chapter invokes the block immediately after it’s defined. In practice, it’s common to pass blocks to functions or methods for invocation elsewhere. You might use Grand Central Dispatch to invoke a block in the background, for example, or define a block to represent a task to be invoked repeatedly, such as when enumerating a collection. Concurrency and enumeration are covered later in this chapter.</p><p>Blocks are also used for callbacks, defining the code to be executed when a task completes. As an example, your app might need to respond to a user action by creating an object that performs a complicated task, such as requesting information from a web service. Because the task might take a long time, you should display some kind of progress indicator while the task is occurring, then hide that indicator once the task is complete.</p><p>It would be possible to accomplish this using delegation: You’d need to create a suitable delegate protocol, implement the required method, set your object as the delegate of the task, then wait for it to call a delegate method on your object once the task finished.</p><p>Blocks make this much easier, however, because you can define the callback behavior at the time you initiate the task, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (IBAction)fetchRemoteInformation:(id)sender {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self showProgressIndicator];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    XYZWebTask *task = ...<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [task beginTaskWithCallbackBlock:^{<span></span></pre></td></tr><tr><td scope="row"><pre>        [self hideProgressIndicator];<span></span></pre></td></tr><tr><td scope="row"><pre>    }];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This example calls a method to display the progress indicator, then creates the task and tells it to start. The callback block specifies the code to be executed once the task completes; in this case, it simply calls a method to hide the progress indicator. Note that this callback block captures <code>self</code> in order to be able to call the <code>hideProgressIndicator</code> method when invoked. It’s important to take care when capturing <code>self</code> because it’s easy to create a strong reference cycle, as described later in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40011210-CH8-SW16" data-renderer-version="1">Avoid Strong Reference Cycles when Capturing self</a></span>.</p><p>In terms of code readability, the block makes it easy to see in one place exactly what will happen before and after the task completes, avoiding the need to trace through delegate methods to find out what’s going to happen.</p><p>The declaration for the <code>beginTaskWithCallbackBlock:</code> method shown in this example would look like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock;<span></span></pre></td></tr></table></div><p>The <code>(void (^)(void))</code> specifies that the parameter is a block that doesn’t take any arguments or return any values. The implementation of the method can invoke the block in the usual way:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock {<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    callbackBlock();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Method parameters that expect a block with one or more arguments are specified in the same way as with a block variable:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)doSomethingWithBlock:(void (^)(double, double))block {<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    block(21.0, 2.0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW14" title="A Block Should Always Be the Last Argument to a Method"></a><h4 class="jump">A Block Should Always Be the Last Argument to a Method</h4><p>It’s best practice to use only one block argument to a method. If the method also needs other non-block arguments, the block should come last:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)beginTaskWithName:(NSString *)name completion:(void(^)(void))callback;<span></span></pre></td></tr></table></div><p>This makes the method call easier to read when specifying the block inline, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    [self beginTaskWithName:@"MyTask" completion:^{<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"The task is complete");<span></span></pre></td></tr><tr><td scope="row"><pre>    }];<span></span></pre></td></tr></table></div></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW11" title="Use Type Definitions to Simplify Block Syntax"></a><h3 class="jump">Use Type Definitions to Simplify Block Syntax</h3><p>If you need to define more than one block with the same signature, you might like to define your own type for that signature.</p><p>As an example, you can define a type for a simple block with no arguments or return value, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>typedef void (^XYZSimpleBlock)(void);<span></span></pre></td></tr></table></div><p>You can then use your custom type for method parameters or when creating block variables:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    XYZSimpleBlock anotherBlock = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)beginFetchWithCallbackBlock:(XYZSimpleBlock)callbackBlock {<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    callbackBlock();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Custom type definitions are particularly useful when dealing with blocks that return blocks or take other blocks as arguments. Consider the following example:</p><div class="codesample clear"><table><tr><td scope="row"><pre>void (^(^complexBlock)(void (^)(void)))(void) = ^ (void (^aBlock)(void)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    return ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The <code>complexBlock</code> variable refers to a block that takes another block as an argument (<code>aBlock</code>) and returns yet another block. </p><p>Rewriting the code to use a type definition makes this much more readable:</p><div class="codesample clear"><table><tr><td scope="row"><pre>XYZSimpleBlock (^betterBlock)(XYZSimpleBlock) = ^ (XYZSimpleBlock aBlock) {<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    return ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW12" title="Objects Use Properties to Keep Track of Blocks"></a><h3 class="jump">Objects Use Properties to Keep Track of Blocks</h3><p>The syntax to define a property to keep track of a block is similar to a block variable:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface XYZObject : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>@property (copy) void (^blockProperty)(void);<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40011210-CH8-SW8" title="Note"></a><p><strong>Note:</strong>&nbsp;You should specify <code>copy</code> as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. For more information, see <em><a href="../../Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" data-renderer-version="1" target="_self">Blocks Programming Topics</a></em>.</p><p></p></aside></div><p>A block property is set or invoked like any other block variable:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    self.blockProperty = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>    self.blockProperty();<span></span></pre></td></tr></table></div><p>It’s also possible to use type definitions for block property declarations, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>typedef void (^XYZSimpleBlock)(void);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface XYZObject : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>@property (copy) XYZSimpleBlock blockProperty;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW16" title="Avoid Strong Reference Cycles when Capturing self"></a><h3 class="jump">Avoid Strong Reference Cycles when Capturing self</h3><p>If you need to capture <code>self</code> in a block, such as when defining a callback block, it’s important to consider the memory management implications.</p><p>Blocks maintain strong references to any captured objects, including <code>self</code>, which means that it’s easy to end up with a strong reference cycle if, for example, an object maintains a <code>copy</code> property for a block that captures <code>self</code>:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface XYZBlockKeeper : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>@property (copy) void (^block)(void);<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><div class="codesample clear"><table><tr><td scope="row"><pre>@implementation XYZBlockKeeper<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)configureBlock {<span></span></pre></td></tr><tr><td scope="row"><pre>    self.block = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        [self doSomething];    // capturing a strong reference to self<span></span></pre></td></tr><tr><td scope="row"><pre>                               // creates a strong reference cycle<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The compiler will warn you for a simple example like this, but a more complex example might involve multiple strong references between objects to create the cycle, making it more difficult to diagnose.</p><p>To avoid this problem, it’s best practice to capture a weak reference to <code>self</code>, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)configureBlock {<span></span></pre></td></tr><tr><td scope="row"><pre>    XYZBlockKeeper * __weak weakSelf = self;<span></span></pre></td></tr><tr><td scope="row"><pre>    self.block = ^{<span></span></pre></td></tr><tr><td scope="row"><pre>        [weakSelf doSomething];   // capture the weak reference<span></span></pre></td></tr><tr><td scope="row"><pre>                                  // to avoid the reference cycle<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>By capturing the weak pointer to <code>self</code>, the block won’t maintain a strong relationship back to the <code>XYZBlockKeeper</code> object. If that object is deallocated before the block is called, the <code>weakSelf</code> pointer will simply be set to <code>nil</code>.</p></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW5" title="Blocks Can Simplify Enumeration"></a><h2 class="jump">Blocks Can Simplify Enumeration</h2><p>In addition to general completion handlers, many Cocoa and Cocoa Touch API use blocks to simplify common tasks, such as collection enumeration. The <code>NSArray</code> class, for example, offers three block-based methods, including:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block;<span></span></pre></td></tr></table></div><p>This method takes a single argument, which is a block to be invoked once for each item in the array:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    NSArray *array = ...<span></span></pre></td></tr><tr><td scope="row"><pre>    [array enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL *stop) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Object at index %lu is %@", idx, obj);<span></span></pre></td></tr><tr><td scope="row"><pre>    }];<span></span></pre></td></tr></table></div><p>The block itself takes three arguments, the first two of which refer to the current object and its index in the array. The third argument is a pointer to a Boolean variable that you can use to stop the enumeration, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    [array enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL *stop) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (...) {<span></span></pre></td></tr><tr><td scope="row"><pre>            *stop = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }];<span></span></pre></td></tr></table></div><p>It’s also possible to customize the enumeration by using the <code>enumerateObjectsWithOptions:usingBlock:</code> method. Specifying the <code>NSEnumerationReverse</code> option, for example, will iterate through the collection in reverse order.</p><p>If the code in the enumeration block is processor-intensive—and safe for concurrent execution—you can use the <code>NSEnumerationConcurrent</code> option:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    [array enumerateObjectsWithOptions:NSEnumerationConcurrent<span></span></pre></td></tr><tr><td scope="row"><pre>                            usingBlock:^ (id obj, NSUInteger idx, BOOL *stop) {<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    }];<span></span></pre></td></tr></table></div><p>This flag indicates that the enumeration block invocations may be distributed across multiple threads, offering a potential performance increase if the block code is particularly processor intensive. Note that the enumeration order is undefined when using this option.</p><p>The <code>NSDictionary</code> class also offers block-based methods, including:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    NSDictionary *dictionary = ...<span></span></pre></td></tr><tr><td scope="row"><pre>    [dictionary enumerateKeysAndObjectsUsingBlock:^ (id key, id obj, BOOL *stop) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"key: %@, value: %@", key, obj);<span></span></pre></td></tr><tr><td scope="row"><pre>    }];<span></span></pre></td></tr></table></div><p>This makes it more convenient to enumerate each key-value pair than when using a traditional loop, for example.</p></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW6" title="Blocks Can Simplify Concurrent Tasks"></a><h2 class="jump">Blocks Can Simplify Concurrent Tasks</h2><p>A block represents a distinct unit of work, combining executable code with optional state captured from the surrounding scope. This makes it ideal for asynchronous invocation using one of the concurrency options available for OS X and iOS. Rather than having to figure out how to work with low-level mechanisms like threads, you can simply define your tasks using blocks and then let the system perform those tasks as processor resources become available.</p><p>OS X and iOS offer a variety of technologies for concurrency, including two task-scheduling mechanisms: Operation queues and Grand Central Dispatch. These mechanisms revolve around the idea of a queue of tasks waiting to be invoked. You add your blocks to a queue in the order you need them to be invoked, and the system dequeues them for invocation when processor time and resources become available.</p><p>A <em class="newTerm">serial queue</em> only allows one task to execute at a time—the next task in the queue won’t be dequeued and invoked until the previous task has finished. A <em class="newTerm">concurrent queue</em> invokes as many tasks as it can, without waiting for previous tasks to finish.</p><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW13" title="Use Block Operations with Operation Queues"></a><h3 class="jump">Use Block Operations with Operation Queues</h3><p>An operation queue is the Cocoa and Cocoa Touch approach to task scheduling. You create an <code>NSOperation</code> instance to encapsulate a unit of work along with any necessary data, then add that operation to an <code>NSOperationQueue</code> for execution.</p><p>Although you can create your own custom <code>NSOperation</code> subclass to implement complex tasks, it’s also possible to use the <code>NSBlockOperation</code> to create an operation using a block, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}];<span></span></pre></td></tr></table></div><p>It’s possible to execute an operation manually but operations are usually added either to an existing operation queue or a queue you create yourself, ready for execution:</p><div class="codesample clear"><table><tr><td scope="row"><pre>// schedule task on main queue:<span></span></pre></td></tr><tr><td scope="row"><pre>NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];<span></span></pre></td></tr><tr><td scope="row"><pre>[mainQueue addOperation:operation];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// schedule task on background queue:<span></span></pre></td></tr><tr><td scope="row"><pre>NSOperationQueue *queue = [[NSOperationQueue alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>[queue addOperation:operation];<span></span></pre></td></tr></table></div><p>If you use an operation queue, you can configure priorities or dependencies between operations, such as specifying that one operation should not be executed until a group of other operations has completed. You can also monitor changes to the state of your operations through key-value observing, which makes it easy to update a progress indicator, for example, when a task completes.</p><p>For more information on operations and operation queues, see <span class="content_text"><a href="../../../../General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101" data-renderer-version="1" target="_self">Operation Queues</a></span>.</p></section><section><a name="//apple_ref/doc/uid/TP40011210-CH8-SW15" title="Schedule Blocks on Dispatch Queues with Grand Central Dispatch"></a><h3 class="jump">Schedule Blocks on Dispatch Queues with Grand Central Dispatch</h3><p>If you need to schedule an arbitrary block of code for execution, you can work directly with <em class="newTerm">dispatch queues</em> controlled by Grand Central Dispatch (GCD). Dispatch queues make it easy to perform tasks either synchronously or asynchronously with respect to the caller, and execute their tasks in a first-in, first-out order.</p><p>You can either create your own dispatch queue or use one of the queues provided automatically by GCD. If you need to schedule a task for concurrent execution, for example, you can get a reference to an existing queue by using the <code>dispatch_get_global_queue()</code> function and specifying a queue priority, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<span></span></pre></td></tr></table></div><p>To dispatch the block to the queue, you use either the <code>dispatch_async()</code> or <code>dispatch_sync()</code> functions. The <code>dispatch_async()</code> function returns immediately, without waiting for the block to be invoked:</p><div class="codesample clear"><table><tr><td scope="row"><pre>dispatch_async(queue, ^{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Block for asynchronous execution");<span></span></pre></td></tr><tr><td scope="row"><pre>});<span></span></pre></td></tr></table></div><p>The <code>dispatch_sync()</code> function doesn’t return until the block has completed execution; you might use it in a situation where a concurrent block needs to wait for another task to complete on the main thread before continuing, for example.</p><p>For more information on dispatch queues and GCD, see <span class="content_text"><a href="../../../../General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102" data-renderer-version="1" target="_self">Dispatch Queues</a></span>.</p></section></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../ErrorHandling/ErrorHandling.html'>Next</a><a class='previousLink' rel='prev' href='../FoundationTypesandCollections/FoundationTypesandCollections.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2014 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2014-09-17</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1260/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/feedback.js"></script>
</body>
</html>
