<!DOCTYPE html>
<html lang="en">
<head>
    <title>Defining Classes</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40011210">
    <meta id="document-version" name="document-version" content="2.7.1">
    <meta id="build" name="build" content="ded95564c405529dbbbe590063edd114" />
    <meta id="chapterId" name="chapterId" content="TP40011210-CH3">
    <meta id="date" name="date" content="2014-09-17">
    <meta id="description" name="description" content="Describes elements of best practice when writing code with Objective-C using ARC.">
    <meta id="book-title" name="book-title" content="Programming with Objective-C">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="Mac Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/mac">
    <meta id="reflib" name="reflib" content="Guides and Sample Code">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Languages & Utilities/Objective-C}">
    
    
    <meta id="copyright" name="copyright" content="Copyright 2017 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Programming with Objective-C: Defining Classes">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1260">
    <link id="book-index-page" rel="Start" title="Programming with Objective-C" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../WorkingwithObjects/WorkingwithObjects.html">
    <link id="previous-page" rel="Prev" type="text/html" href="../Introduction/Introduction.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/feedback.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta id="platforms" name="platforms" content="">
</head>    
<body><a name="//apple_ref/doc/uid/TP40011210-CH3" title="Defining Classes"></a>
    <div id="_omniture_top">
    <!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
    <script type="text/javascript">
    /* RSID: */
    var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
    </script>

    <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
    <script type="text/javascript">
    s.pageName=AC.Tracking.pageName();
    s.channel="www.us.developer"

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)</script>
    <!-- End SiteCatalyst code version: H.8. -->
    </div>

    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode unified">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>Guides and Sample Code</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search Guides and Sample Code</label>
            
            
    
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Programming with Objective-C</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../WorkingwithObjects/WorkingwithObjects.html'>Next</a><a class='previousLink' rel='prev' href='../Introduction/Introduction.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/TP40011210-CH3-SW1" title="Defining Classes"></a><h1 id="pageTitle">Defining Classes</h1><p>When you write software for OS X or iOS, most of your time is spent working with objects. Objects in Objective-C are just like objects in other object-oriented programming languages: they package data with related behavior.</p><p>An app is built as a large ecosystem of interconnected objects that communicate with each other to solve specific problems, such as displaying a visual interface, responding to user input, or storing information. For OS X or iOS development, you don’t need to create objects from scratch to solve every conceivable problem; instead you have a large library of existing objects available for your use, provided by Cocoa (for OS X) and Cocoa Touch (for iOS).</p><p>Some of these objects are immediately usable, such as basic data types like strings and numbers, or user interface elements like buttons and table views. Some are designed for you to customize with your own code to behave in the way you require. The app development process involves deciding how best to customize and combine the objects provided by the underlying frameworks with your own objects to give your app its unique set of features and functionality.</p><p>In object-oriented programming terms, an object is an instance of a class. This chapter demonstrates how to define classes in Objective-C by declaring an interface, which describes the way you intend the class and its instances to be used. This interface includes the list of messages that the class can receive, so you also need to provide the class implementation, which contains the code to be executed in response to each message.</p><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW2" title="Classes Are Blueprints for Objects"></a><h2 class="jump">Classes Are Blueprints for Objects</h2><p>A class describes the behavior and properties common to any particular type of object. For a string object (in Objective-C, this is an instance of the class <code>NSString</code>), the class offers various ways to examine and convert the internal characters that it represents. Similarly, the class used to describe a number object (<code>NSNumber</code>) offers functionality around an internal numeric value, such as converting that value to a different numeric type.</p><p>In the same way that multiple buildings constructed from the same blueprint are identical in structure, every instance of a class shares the same properties and behavior as all other instances of that class. Every <code>NSString</code> instance behaves in the same way, regardless of the internal string of characters it holds.</p><p>Any particular object is designed to be used in specific ways. You might know that a string object represents some string of characters, but you don’t need to know the exact internal mechanisms used to store those characters. You don’t know anything about the internal behavior used by the object itself to work directly with its characters, but you do need to know how you are expected to interact with the object, perhaps to ask it for specific characters or request a new object in which all the original characters are converted to uppercase.</p><p>In Objective-C, the <em class="newTerm">class interface</em> specifies exactly how a given type of object is intended to be used by other objects. In other words, it defines the public interface between instances of the class and the outside world.</p><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW3" title="Mutability Determines Whether a Represented Value Can Be Changed"></a><h3 class="jump">Mutability Determines Whether a Represented Value Can Be Changed</h3><p>Some classes define objects that are <em class="newTerm">immutable</em>. This means that the internal contents must be set when an object is created, and cannot subsequently be changed by other objects. In Objective-C, all basic <code>NSString</code> and <code>NSNumber</code> objects are immutable. If you need to represent a different number, you must use a new <code>NSNumber</code> instance.</p><p>Some immutable classes also offer a <em class="newTerm">mutable</em> version. If you specifically need to change the contents of a string at runtime, for example by appending characters as they are received over a network connection, you can use an instance of the <code>NSMutableString</code> class. Instances of this class behave just like <code>NSString</code> objects, except that they also offer functionality to change the characters that the object represents.</p><p>Although <code>NSString</code> and <code>NSMutableString</code> are different classes, they have many similarities. Rather than writing two completely separate classes from scratch that just happen to have some similar behavior, it makes sense to make use of inheritance.</p></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW4" title="Classes Inherit from Other Classes"></a><h3 class="jump">Classes Inherit from Other Classes</h3><p>In the natural world, taxonomy classifies animals into groups with terms like species, genus, and family. These groups are hierarchical, such that multiple species may belong to one genus, and multiple genera to one family.</p><p>Gorillas, humans, and orangutans, for example, have a number of obvious similarities. Although they each belong to different species, and even different genera, tribes, and subfamilies, they are taxonomically related since they all belong to the same family (called “Hominidae”), as shown in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40011210-CH3-SW16" data-renderer-version="1">Figure 1-1</a></span>.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40011210-CH3-SW16" title="Figure 1-1Taxonomic relationships between species"></a><figcaption><strong class="caption_number">Figure 1-1</strong>&nbsp;&nbsp;Taxonomic relationships between species</figcaption><img src="../Art/humansgorillas.png" class="wide-image" alt="" width="704" height="270"><img src="../Art/humansgorillas.png" class="ipad-scaled-image" alt="" width="670" height="256"></figure><p>In the world of object-oriented programming, objects are also categorized into hierarchical groups. Rather than using distinct terms for the different hierarchical levels such as genus or species, objects are simply organized into classes. In the same way that humans inherit certain characteristics as members of the Hominidae family, a class can be set to inherit functionality from a parent class.</p><p>When one class inherits from another, the child inherits all the behavior and properties defined by the parent. It also has the opportunity either to define its own additional behavior and properties, or override the behavior of the parent.</p><p>In the case of Objective-C string classes, the class description for <code>NSMutableString</code> specifies that the class inherits from <code>NSString</code>, as shown in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40011210-CH3-SW20" data-renderer-version="1">Figure 1-2</a></span>. All of the functionality provided by <code>NSString</code> is available in <code>NSMutableString</code>, such as querying specific characters or requesting new uppercase strings, but <code>NSMutableString</code> adds methods that allow you to append, insert, replace or delete substrings and individual characters.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40011210-CH3-SW20" title="Figure 1-2NSMutableString class inheritance"></a><figcaption><strong class="caption_number">Figure 1-2</strong>&nbsp;&nbsp;NSMutableString class inheritance</figcaption><img src="../Art/nsstringmutablestring.png" alt="" width="372" height="57"></figure></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW19" title="The Root Class Provides Base Functionality"></a><h3 class="jump">The Root Class Provides Base Functionality</h3><p>In the same way that all living organisms share some basic “life” characteristics, some functionality is common across all objects in Objective-C.</p><p>When an Objective-C object needs to work with an instance of another class, it is expected that the other class offers certain basic characteristics and behavior. For this reason, Objective-C defines a root class from which the vast majority of other classes inherit, called <code>NSObject</code>. When one object encounters another object, it expects to be able to interact using at least the basic behavior defined by the <code>NSObject</code> class description.</p><p>When you’re defining your own classes, you should at a minimum inherit from <code>NSObject</code>. In general, you should find a Cocoa or Cocoa Touch object that offers the closest functionality to what you need and inherit from that.</p><p>If you want to define a custom button for use in an iOS app, for example, and the provided <code>UIButton</code> class doesn’t offer enough customizable attributes to satisfy your needs, it makes more sense to create a new class inheriting from <code>UIButton</code> than from <code>NSObject</code>. If you simply inherited from <code>NSObject</code>, you’d need to duplicate all the complex visual interactions and communication defined by the <code>UIButton</code> class just to make your button behave in the way expected by the user. Furthermore, by inheriting from <code>UIButton</code>, your subclass automatically gains any future enhancements or bug fixes that might be applied to the internal <code>UIButton</code> behavior.</p><p>The <code>UIButton</code> class itself is defined to inherit from <code>UIControl</code>, which describes basic behavior common to all user interface controls on iOS. The <code>UIControl</code> class in turn inherits from <code>UIView</code>, giving it functionality common to objects that are displayed on screen. <code>UIView</code> inherits from <code>UIResponder</code>, allowing it to respond to user input such as taps, gestures or shakes. Finally, at the root of the tree, <code>UIResponder</code> inherits from <code>NSObject</code>, as shown in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40011210-CH3-SW21" data-renderer-version="1">Figure 1-3</a></span>.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40011210-CH3-SW21" title="Figure 1-3UIButton class inheritance"></a><figcaption><strong class="caption_number">Figure 1-3</strong>&nbsp;&nbsp;UIButton class inheritance</figcaption><img src="../Art/buttoninheritance.png" class="wide-image" alt="" width="696" height="76"><img src="../Art/buttoninheritance.png" class="ipad-scaled-image" alt="" width="670" height="73"></figure><p>This chain of inheritance means that any custom subclass of <code>UIButton</code> would inherit not only the functionality declared by <code>UIButton</code> itself, but also the functionality inherited from each superclass in turn. You’d end up with a class for an object that behaved like a button, could display itself on screen, respond to user input, and communicate with any other basic Cocoa Touch object.</p><p>It’s important to keep the inheritance chain in mind for any class you need to use, in order to work out exactly what it can do. The class reference documentation provided for Cocoa and Cocoa Touch, for example, allows easy navigation from any class to each of its superclasses. If you can’t find what you’re looking for in one class interface or reference, it may very well be defined or documented in a superclass further up the chain.</p></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW5" title="The Interface for a Class Defines Expected Interactions"></a><h2 class="jump">The Interface for a Class Defines Expected Interactions</h2><p>One of the many benefits of object-oriented programming is the idea mentioned earlier—all you need to know in order to use a class is how to interact with its instances. More specifically, an object should be designed to hide the details of its internal implementation.</p><p>If you use a standard <code>UIButton</code> in an iOS app, for example, you don’t need to worry about how pixels are manipulated so that the button appears on screen. All you need to know is that you can change certain attributes, such as the button’s title and color, and trust that when you add it to your visual interface, it will be displayed correctly and behave in the way you expect.</p><p>When you’re defining your own class, you need to start by figuring out these public attributes and behaviors. What attributes do you want to be accessible publicly? Should you allow those attributes to be changed? How do other objects communicate with instances of your class?</p><p>This information goes into the interface for your class—it defines the way you intend other objects to interact with instances of your class. The public interface is described separately from the <em>internal</em> behavior of your class, which makes up the class implementation. In Objective-C, the interface and implementation are usually placed in separate files so that you only need to make the interface public.</p><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW6" title="Basic Syntax"></a><h3 class="jump">Basic Syntax</h3><p>The Objective-C syntax used to declare a class interface looks like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface SimpleClass : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>This example declares a class named <code>SimpleClass</code>, which inherits from <code>NSObject</code>.</p><p>The public properties and behavior are defined inside the <code>@interface</code> declaration. In this example, nothing is specified beyond the superclass, so the only functionality expected to be available on instances of <code>SimpleClass</code> is the functionality inherited from <code>NSObject</code>.</p></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW7" title="Properties Control Access to an Object’s Values"></a><h3 class="jump">Properties Control Access to an Object’s Values</h3><p>Objects often have properties intended for public access. If you define a class to represent a human being in a record-keeping app, for example, you might decide you need properties for strings representing a person’s first and last names.</p><p>Declarations for these properties should be added inside the interface, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface Person : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@property NSString *firstName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property NSString *lastName;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>In this example, the <code>Person</code> class declares two public properties, both of which are instances of the <code>NSString</code> class. </p><p>Both these properties are for Objective-C objects, so they use an <em>asterisk</em> to indicate that they are C pointers. They are also statements just like any other variable declaration in C, and therefore require a semi-colon at the end.</p><p>You might decide to add a property to represent a person’s year of birth to allow you to sort people in year groups rather than just by name. You could use a property for a number <em>object</em>:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@property NSNumber *yearOfBirth;<span></span></pre></td></tr></table></div><p>but this might be considered overkill just to store a simple numeric value. One alternative would be to use one of the primitive types provided by C, which hold scalar values, such as an integer:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@property int yearOfBirth;<span></span></pre></td></tr></table></div><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW9" title="Property Attributes Indicate Data Accessibility and Storage Considerations"></a><h4 class="jump">Property Attributes Indicate Data Accessibility and Storage Considerations</h4><p>The examples shown so far all declare properties that are intended for complete public access. This means that other objects can both read and change the values of the properties.</p><p>In some cases, you might decide to declare that a property is not intended to be changed. In the real world, a person must fill out a large amount of paperwork to change their documented first or last name. If you were writing an official record-keeping app, you might choose that the public properties for a person’s name be specified as read-only, requiring that any changes be requested through an intermediary object responsible for validating the request and approving or denying it.</p><p>Objective-C property declarations can include <em>property attributes</em>, which are used to indicate, among other things, whether a property is intended to be read-only. In an official record-keeping app, the Person class interface might look like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface Person : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readonly) NSString *firstName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readonly) NSString *lastName;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Property attributes are specified inside parentheses after the <code>@property</code> keyword, and are described fully in <span class="content_text"><a href="../EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW4" data-renderer-version="1">Declare Public Properties for Exposed Data</a></span>.</p></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW8" title="Method Declarations Indicate the Messages an Object Can Receive"></a><h3 class="jump">Method Declarations Indicate the Messages an Object Can Receive</h3><p>The examples so far have involved a class describing a typical <span class="pediaLink" data-header="Model object" data-contents="A model object is a type of object that contains the data of an application, provides access to that data, and implements logic to manipulate the data. "><a href="../../../../General/Conceptual/DevPedia-CocoaCore/ModelObject.html#//apple_ref/doc/uid/TP40008195-CH31" data-renderer-version="1" target="_self">model</a></span> object, or an object designed primarily to encapsulate data. In the case of a <code>Person</code> class, it’s possible that there wouldn’t need to be any functionality beyond being able to access the two declared properties. The majority of classes, however, do include behavior in addition to any declared properties.</p><p>Given that Objective-C software is built from a large network of objects, it’s important to note that those objects can interact with each other by sending messages. In Objective-C terms, one object sends a message to another object by calling a method on that object.</p><p>Objective-C methods are conceptually similar to standard functions in C and other programming languages, though the syntax is quite different. A C function declaration looks like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>void SomeFunction();<span></span></pre></td></tr></table></div><p>The equivalent Objective-C method declaration looks like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)someMethod;<span></span></pre></td></tr></table></div><p>In this case, the method has no parameters. The C <code>void</code> keyword is used inside parentheses at the beginning of the declaration to indicate that the method doesn’t return any value once it’s finished.</p><p>The minus sign (<code>-</code>) at the front of the method name indicates that it is an instance method, which can be called on any instance of the class. This differentiates it from class methods, which can be called on the class itself, as described in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40011210-CH3-SW18" data-renderer-version="1">Objective-C Classes Are also Objects</a></span>.</p><p>As with C function prototypes, a method declaration inside an Objective-C class interface is just like any other C statement and requires a terminating semi-colon.</p><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW11" title="Methods Can Take Parameters"></a><h4 class="jump">Methods Can Take Parameters</h4><p>If you need to declare a method to take one or more parameters, the syntax is very different to a typical C function.</p><p>For a C function, the parameters are specified inside parentheses, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>void SomeFunction(SomeType value);<span></span></pre></td></tr></table></div><p>An Objective-C method declaration includes the parameters as part of its name, using colons, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)someMethodWithValue:(SomeType)value;<span></span></pre></td></tr></table></div><p>As with the return type, the parameter type is specified in parentheses, just like a standard C type-cast.</p><p>If you need to supply multiple parameters, the syntax is again quite different from C. Multiple parameters to a C function are specified inside the parentheses, separated by commas; in Objective-C, the declaration for a method taking two parameters looks like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)someMethodWithFirstValue:(SomeType)value1 secondValue:(AnotherType)value2;<span></span></pre></td></tr></table></div><p>In this example, <code>value1</code> and <code>value2</code> are the names used in the implementation to access the values supplied when the method is called, as if they were variables.</p><p>Some programming languages allow function definitions with so-called <em>named arguments</em>; it’s important to note that this is not the case in Objective-C. The order of the parameters in a method call must match the method declaration, and in fact the <code>secondValue:</code> portion of the method declaration is part of the name of the method:</p><div class="codesample clear"><table><tr><td scope="row"><pre>someMethodWithFirstValue:secondValue:<span></span></pre></td></tr></table></div><p>This is one of the features that helps make Objective-C such a readable language, because the values passed by a method call are specified <em>inline</em>, next to the relevant portion of the method name, as described in <span class="content_text"><a href="../WorkingwithObjects/WorkingwithObjects.html#//apple_ref/doc/uid/TP40011210-CH4-SW13" data-renderer-version="1">You Can Pass Objects for Method Parameters</a></span>.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40011210-CH3-SW10" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>value1</code> and <code>value2</code> value names used above aren’t strictly part of the method declaration, which means it’s not necessary to use exactly the same value names in the declaration as you do in the implementation. The only requirement is that the signature matches, which means you must keep the name of the method as well as the parameter and return types exactly the same.</p><p>As an example, this method has the same signature as the one shown above:</p><p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;<span></span></pre></td></tr></table></div>These methods have different signatures to the one above:</p><p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)someMethodWithFirstValue:(SomeType)info1 anotherValue:(AnotherType)info2;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)someMethodWithFirstValue:(SomeType)info1 secondValue:(YetAnotherType)info2;<span></span></pre></td></tr></table></div></p></aside></div></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW12" title="Class Names Must Be Unique"></a><h3 class="jump">Class Names Must Be Unique</h3><p>It’s important to note that the name of each class must be unique within an app, even across included libraries or frameworks. If you attempt to create a new class with the same name as an existing class in a project, you’ll receive a compiler error.</p><p>For this reason, it’s advisable to prefix the names of any classes you define, using three or more letters. These letters might relate to the app you’re currently writing, or to the name of a framework of reusable code, or perhaps just your initials. </p><p>All examples given in the rest of this document use class name prefixes, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface XYZPerson : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readonly) NSString *firstName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readonly) NSString *lastName;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40011210-CH3-SW13" title="Historical Note"></a><p><strong>Historical Note:</strong>&nbsp;If you’re wondering why so many of the classes you encounter have an <code>NS</code> prefix, it’s because of the past history of Cocoa and Cocoa Touch. Cocoa began life as the collected frameworks used to build apps for the NeXTStep operating system. When Apple purchased NeXT back in 1996, much of NeXTStep was incorporated into OS X, including the existing class names. Cocoa <em>Touch</em> was introduced as the iOS equivalent of Cocoa; some classes are available in both Cocoa and Cocoa Touch, though there are also a large number of classes unique to each platform.</p><p>Two-letter prefixes like <code>NS</code> and <code>UI</code> (for User Interface elements on iOS) are reserved for use by Apple.</p><p></p></aside></div><p>Method and property names, by contrast, need only be unique within the class in which they are defined. Although every C function in an app must have a unique name, it’s perfectly acceptable (and often desirable) for multiple Objective-C classes to define methods with the same name. You can’t define a method more than once within the same class declaration, however, though if you wish to override a method inherited from a parent class, you must use the exact name used in the original declaration.</p><p>As with methods, an object’s properties and instance variables (described in <span class="content_text"><a href="../EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6" data-renderer-version="1">Most Properties Are Backed by Instance Variables</a></span>) need to be unique only within the class in which they are defined. If you make use of global variables, however, these must be named uniquely within an app or project.</p><p>Further naming conventions and suggestions are given in <span class="content_text"><a href="../Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1" data-renderer-version="1">Conventions</a></span>.</p></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW14" title="The Implementation of a Class Provides Its Internal Behavior"></a><h2 class="jump">The Implementation of a Class Provides Its Internal Behavior</h2><p>Once you’ve defined the interface for a class, including the properties and methods intended for public access, you need to write the code to implement the class behavior.</p><p>As stated earlier, the interface for a class is usually placed inside a dedicated file, often referred to as a <em class="newTerm">header file</em>, which generally has the filename extension <code>.h</code>. You write the implementation for an Objective-C class inside a source code file with the extension <code>.m</code>.</p><p>Whenever the interface is defined in a header file, you’ll need to tell the compiler to read it before trying to compile the implementation in the source code file. Objective-C provides a preprocessor directive, <code>#import</code>, for this purpose. It’s similar to the C <code>#include</code> directive, but makes sure that a file is only included once during compilation.</p><p>Note that preprocessor directives are different from traditional C statements and do not use a terminating semi-colon.</p><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW15" title="Basic Syntax"></a><h3 class="jump">Basic Syntax</h3><p>The basic syntax to provide the implementation for a class looks like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>#import "XYZPerson.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation XYZPerson<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>If you declare any methods in the class interface, you’ll need to implement them inside this file.</p></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW17" title="Implementing Methods"></a><h3 class="jump">Implementing Methods</h3><p>For a simple class interface with one method, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>@interface XYZPerson : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sayHello;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>the implementation might look like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>#import "XYZPerson.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation XYZPerson<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sayHello {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Hello, World!");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>This example uses the <code>NSLog()</code> function to log a message to the console. It’s similar to the standard C library <code>printf()</code> function, and takes a variable number of parameters, the first of which must be an Objective-C string.</p><p>Method implementations are similar to C function definitions in that they use braces to contain the relevant code. Furthermore, the name of the method must be identical to its prototype, and the parameter and return types must match exactly. </p><p>Objective-C inherits case sensitivity from C, so this method:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)sayhello {<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>would be treated by the compiler as completely different to the <code>sayHello</code> method shown earlier.</p><p>In general, method names should begin with a lowercase letter. The Objective-C convention is to use more descriptive names for methods than you might see used for typical C functions. If a method name involves multiple words, use camel case (capitalizing the first letter of each new word) to make them easy to read.</p><p>Note also that whitespace is flexible in Objective-C. It’s customary to indent each line inside any block of code using either tabs or spaces, and you’ll often see the opening left brace on a separate line, like this:</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)sayHello<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"Hello, World!");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Xcode, Apple’s integrated development environment (IDE) for creating OS X and iOS software, will automatically indent your code based on a set of customizable user preferences. See <span class="content_text"><!--a target="_self" -->Changing the Indent and Tab Width<!--/a--></span> in <em><!--a target="_self" -->Xcode Workspace Guide<!--/a--></em> for more information.</p><p>You’ll see many more examples of method implementations in the next chapter, <span class="content_text"><a href="../WorkingwithObjects/WorkingwithObjects.html#//apple_ref/doc/uid/TP40011210-CH4-SW1" data-renderer-version="1">Working with Objects</a></span>.</p></section></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW18" title="Objective-C Classes Are also Objects"></a><h2 class="jump">Objective-C Classes Are also Objects</h2><p>In Objective-C, a class is itself an object with an opaque type called <code>Class</code>. Classes can’t have properties defined using the declaration syntax shown earlier for instances, but they can receive messages.</p><p>The typical use for a class method is as a <em class="newTerm">factory method</em>, which is an alternative to the object allocation and initialization procedure described in <span class="content_text"><a href="../WorkingwithObjects/WorkingwithObjects.html#//apple_ref/doc/uid/TP40011210-CH4-SW7" data-renderer-version="1">Objects Are Created Dynamically</a></span>. The <code>NSString</code> class, for example, has a variety of factory methods available to create either an empty string object, or a string object initialized with specific characters, including:</p><div class="codesample clear"><table><tr><td scope="row"><pre>+ (id)string;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)stringWithString:(NSString *)aString;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)stringWithFormat:(NSString *)format, …;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;<span></span></pre></td></tr><tr><td scope="row"><pre>+ (id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;<span></span></pre></td></tr></table></div><p>As shown in these examples, class methods are denoted by the use of a <code>+</code> sign, which differentiates them from instance methods using a <code>-</code> sign.</p><p>Class method prototypes may be included in a class interface, just like instance method prototypes. Class methods are implemented in the same way as instance methods, inside the <code>@implementation</code> block for the class.</p></section><section><a name="//apple_ref/doc/uid/TP40011210-CH3-SW22" title="Exercises"></a><h2 class="jump">Exercises</h2><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40011210-CH3-SW24" title="Note"></a><p><strong>Note:</strong>&nbsp;In order to follow the exercises given at the end of each chapter, you may wish to create an Xcode project. This will allow you to make sure that your code compiles without errors.</p><p>Use Xcode’s New Project template window to create a <em>Command Line Tool</em> from the available OS X Application project templates. When prompted, specify the project’s Type as <em>Foundation</em>.</p><p></p></aside></div><ol class="ol"><li class="li"><p>Use Xcode’s New File template window to create the interface and implementation files for an Objective-C class called <code>XYZPerson</code>, which inherits from <code>NSObject</code>.</p></li><li class="li"><p>Add properties for a person’s first name, last name and date of birth (dates are represented by the <code>NSDate</code> class) to the <code>XYZPerson</code> class interface.</p></li><li class="li"><p>Declare the <code>sayHello</code> method and implement it as shown earlier in the chapter.</p></li><li class="li"><p>Add a declaration for a class factory method, called “<code>person</code>”. Don’t worry about implementing this method until you’ve read the next chapter.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40011210-CH3-SW23" title="Note"></a><p><strong>Note:</strong>&nbsp;If you’re compiling the code, you’ll get a warning about an “Incomplete implementation” due to this missing implementation.</p><p></p></aside></div></li></ol></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../WorkingwithObjects/WorkingwithObjects.html'>Next</a><a class='previousLink' rel='prev' href='../Introduction/Introduction.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2014 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2014-09-17</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1260/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/feedback.js"></script>
</body>
</html>
