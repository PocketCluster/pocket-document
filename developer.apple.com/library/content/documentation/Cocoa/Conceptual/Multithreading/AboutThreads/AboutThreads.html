<!DOCTYPE html>
<html lang="en">
<head>
    <title>About Threaded Programming</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/10000057i">
    <meta id="document-version" name="document-version" content="5.6.3">
    <meta id="build" name="build" content="ded95564c405529dbbbe590063edd114" />
    <meta id="chapterId" name="chapterId" content="10000057i-CH6">
    <meta id="date" name="date" content="2014-07-15">
    <meta id="description" name="description" content="Explains how to use threads in Cocoa applications.">
    <meta id="book-title" name="book-title" content="Threading Programming Guide">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="Mac Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/mac">
    <meta id="reflib" name="reflib" content="Guides and Sample Code">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Performance}">
    
    
    <meta id="copyright" name="copyright" content="Copyright 2017 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Threading Programming Guide: About Threaded Programming">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1260">
    <link id="book-index-page" rel="Start" title="Threading Programming Guide" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../CreatingThreads/CreatingThreads.html">
    <link id="previous-page" rel="Prev" type="text/html" href="../Introduction/Introduction.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/feedback.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta id="platforms" name="platforms" content="">
</head>    
<body><a name="//apple_ref/doc/uid/10000057i-CH6" title="About Threaded Programming"></a>
    <div id="_omniture_top">
    <!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
    <script type="text/javascript">
    /* RSID: */
    var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
    </script>

    <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
    <script type="text/javascript">
    s.pageName=AC.Tracking.pageName();
    s.channel="www.us.developer"

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)</script>
    <!-- End SiteCatalyst code version: H.8. -->
    </div>

    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode unified">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>Guides and Sample Code</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search Guides and Sample Code</label>
            
            
    
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Threading Programming Guide</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../CreatingThreads/CreatingThreads.html'>Next</a><a class='previousLink' rel='prev' href='../Introduction/Introduction.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/10000057i-CH6-SW2" title="About Threaded Programming"></a><h1 id="pageTitle">About Threaded Programming</h1><p>For many years, maximum computer performance was limited largely by the speed of a single microprocessor at the heart of the computer. As the speed of individual processors started reaching their practical limits, however, chip makers switched to multicore designs, giving the computer the opportunity to perform multiple tasks simultaneously. And although OS X takes advantage of these cores whenever it can to perform system-related tasks, your own applications can also take advantage of them through threads. </p><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW3" title="What Are Threads?"></a><h2 class="jump">What Are Threads?</h2><p>Threads are a relatively lightweight way to implement multiple paths of execution inside of an application. At the system level, programs run side by side, with the system doling out execution time to each program based on its needs and the needs of other programs. Inside each program, however, exists one or more threads of execution, which can be used to perform different tasks simultaneously or in a nearly simultaneous manner. The system itself actually manages these threads of execution, scheduling them to run on the available cores and preemptively interrupting them as needed to allow other threads to run.</p><p>From a technical standpoint, a thread is a combination of the kernel-level and application-level data structures needed to manage the execution of code. The kernel-level structures coordinate the dispatching of events to the thread and the preemptive scheduling of the thread on one of the available cores. The application-level structures include the call stack for storing function calls and the structures the application needs to manage and manipulate the thread’s attributes and state.</p><p>In a non-concurrent application, there is only one thread of execution. That thread starts and ends with your application’s <code>main</code> routine and branches one-by-one to different methods or functions to implement the application’s overall behavior. By contrast, an application that supports concurrency starts with one thread and adds more as needed to create additional execution paths. Each new path has its own custom start routine that runs independently of the code in the application’s <code>main</code> routine. Having multiple threads in an application provides two very important potential advantages: </p><ul class="ul"><li class="li"><p>Multiple threads can improve an application’s perceived responsiveness.</p></li><li class="li"><p>Multiple threads can improve an application’s real-time performance on multicore systems.</p></li></ul><p>If your application has only one thread, that one thread must do everything. It must respond to events, update your application’s windows, and perform all of the computations needed to implement your application’s behavior. The problem with having just one thread is that it can only do one thing at a time. So what happens when one of your computations takes a long time to finish? While your code is busy computing the values it needs, your application stops responding to user events and updating its windows. If this behavior continues long enough, a user might think your application is hung and try to forcibly quit it. If you moved your custom computations onto a separate thread, however, your application’s main thread would be free to respond to user interactions in a more timely manner. </p><p>With multicore computers common these days, threads provide a way to increase performance in some types of applications. Threads that perform different tasks can do so simultaneously on different processor cores, making it possible for an application to increase the amount of work it does in a given amount of time. </p><p>Of course, threads are not a panacea for fixing an application’s performance problems. Along with the benefits offered by threads come the potential problems. Having multiple paths of execution in an application can add a considerable amount of complexity to your code. Each thread has to coordinate its actions with other threads to prevent it from corrupting the application’s state information. Because threads in a single application share the same memory space, they have access to all of the same data structures. If two threads try to manipulate the same data structure at the same time, one thread might overwrite another’s changes in a way that corrupts the resulting data structure. Even with proper protections in place, you still have to watch out for compiler optimizations that introduce subtle (and not so subtle) bugs into your code. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW25" title="Threading Terminology"></a><h2 class="jump">Threading Terminology</h2><p>Before getting too far into discussions about threads and their supporting technologies, it is necessary to define some basic terminology. </p><p>If you are familiar with UNIX systems, you may find that the term “task” is used differently by this document. On UNIX systems, the term “task” is used at times to refer to a running process.</p><p>This document adopts the following terminology:</p><ul class="ul"><li class="li"><p>The term <em class="newTerm">thread</em> is used to refer to a separate path of execution for code.</p></li><li class="li"><p>The term <em class="newTerm">process</em> is used to refer to a running executable, which can encompass multiple threads.</p></li><li class="li"><p>The term <em class="newTerm">task</em> is used to refer to the abstract concept of work that needs to be performed.</p></li></ul></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW15" title="Alternatives to Threads"></a><h2 class="jump">Alternatives to Threads</h2><p>One problem with creating threads yourself is that they add uncertainty to your code. Threads are a relatively low-level and complicated way to support concurrency in your application. If you do not fully understand the implications of your design choices, you could easily encounter synchronization or timing issues, the severity of which can range from subtle behavioral changes to the crashing of your application and the corruption of the user’s data.</p><p>Another factor to consider is whether you need threads or concurrency at all. Threads solve the specific problem of how to execute multiple code paths concurrently inside the same process. There may be cases, though, where the amount of work you are doing does not warrant concurrency. Threads introduce a tremendous amount of overhead to your process, both in terms of memory consumption and CPU time. You may discover that this overhead is too great for the intended task, or that other options are easier to implement.</p><p><span class="content_text">Table 1-1</span> lists some of the alternatives to threads. This table includes both replacement technologies for threads (such as operation objects and GCD) and alternatives that are geared towards efficiently using the single thread you already have. </p><a name="//apple_ref/doc/uid/10000057i-CH6-SW1" title="Table 1-1Alternative technologies to threads"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 1-1</strong>&nbsp;&nbsp;Alternative technologies to threads</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Technology</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p>Operation objects</p></td><td ><p>Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads. </p><p>For more information on how to use operation objects, see <em><a href="../../../../General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" data-renderer-version="1" target="_self">Concurrency Programming Guide</a></em>.</p></td></tr><tr><td  scope="row"><p>Grand Central Dispatch (GCD)</p></td><td ><p>Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads. </p><p>For information on how to use GCD and work queues, see <em><a href="../../../../General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" data-renderer-version="1" target="_self">Concurrency Programming Guide</a></em></p></td></tr><tr><td  scope="row"><p>Idle-time notifications</p></td><td ><p>For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the <code><a href="https://developer.apple.com/reference/foundation/notificationqueue" target="_self" class="urlLink">NSNotificationQueue</a></code> object. To request an idle-time notification, post a notification to the default <code>NSNotificationQueue</code> object using the <code><a href="https://developer.apple.com/reference/foundation/notificationqueue.postingstyle/1418001-whenidle" target="_self" class="urlLink">NSPostWhenIdle</a></code> option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see <em><a href="../../Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i" data-renderer-version="1" target="_self">Notification Programming Topics</a></em>. </p></td></tr><tr><td  scope="row"><p>Asynchronous functions</p></td><td ><p>The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread.</p></td></tr><tr><td  scope="row"><p>Timers</p></td><td ><p>You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW21" data-renderer-version="1">Timer Sources</a></span>. </p></td></tr><tr><td  scope="row"><p>Separate processes</p></td><td ><p>Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user. </p></td></tr></table></div><div class="warningbox clear"><aside><a name="//apple_ref/doc/uid/10000057i-CH6-DontLinkElementID_5" title="Warning"></a><p><strong>Warning:</strong>&nbsp;When launching separate processes using the <code>fork</code> function, you must always follow a call to <code>fork</code> with a call to <code>exec</code> or a similar function. Applications that depend on the Core Foundation, Cocoa, or Core Data frameworks (either explicitly or implicitly) must make a subsequent call to an <code>exec</code> function or those frameworks may behave improperly.</p><p></p><div class="clear"></div></aside></div></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW4" title="Threading Support"></a><h2 class="jump">Threading Support</h2><p>If you have existing code that uses threads, OS X and iOS provide several technologies for creating threads in your applications. In addition, both systems also provide support for managing and synchronizing the work that needs to be done on those threads. The following sections describe some of the key technologies that you need to be aware of when working with threads in OS X and iOS.</p><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW5" title="Threading Packages"></a><h3 class="jump">Threading Packages</h3><p>Although the underlying implementation mechanism for threads is Mach threads, you rarely (if ever) work with threads at the Mach level. Instead, you usually use the more convenient POSIX API or one of its derivatives. The Mach implementation does provide the basic features of all threads, however, including the preemptive execution model and the ability to schedule threads so they are independent of each other. </p><p><span class="content_text">Listing 2-2</span> lists the threading technologies you can use in your applications. </p><a name="//apple_ref/doc/uid/10000057i-CH6-SW6" title="Table 1-2Thread technologies"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 1-2</strong>&nbsp;&nbsp;Thread technologies</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Technology</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p>Cocoa threads </p></td><td ><p>Cocoa implements threads using the <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> class. Cocoa also provides methods on <code><a href="https://developer.apple.com/reference/objectivec/nsobject" target="_self" class="urlLink">NSObject</a></code> for spawning new threads and executing code on already-running threads. For more information, see <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW11" data-renderer-version="1">Using NSThread</a></span> and <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW13" data-renderer-version="1">Using NSObject to Spawn a Thread</a></span>.</p></td></tr><tr><td  scope="row"><p>POSIX threads</p></td><td ><p>POSIX threads provide a C-based interface for creating threads. If you are not writing a Cocoa application, this is the best choice for creating threads. The POSIX interface is relatively simple to use and offers ample flexibility for configuring your threads. For more information, see <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW12" data-renderer-version="1">Using POSIX Threads</a></span></p></td></tr><tr><td  scope="row"><p>Multiprocessing Services</p></td><td ><p>Multiprocessing Services is a legacy C-based interface used by applications transitioning from older versions of Mac OS. This technology is available in OS X only and should be avoided for any new development. Instead, you should use the <code>NSThread</code> class or POSIX threads. If you need more information on this technology, see <em><!--a target="_self" -->Multiprocessing Services Programming Guide<!--/a--></em>. </p></td></tr></table></div><p>At the application level, all threads behave in essentially the same way as on other platforms. After starting a thread, the thread runs in one of three main states: running, ready, or blocked. If a thread is not currently running, it is either blocked and waiting for input or it is ready to run but not scheduled to do so yet. The thread continues moving back and forth among these states until it finally exits and moves to the terminated state.</p><p>When you create a new thread, you must specify an entry-point function (or an entry-point method in the case of Cocoa threads) for that thread. This entry-point function constitutes the code you want to run on the thread. When the function returns, or when you terminate the thread explicitly, the thread stops permanently and is reclaimed by the system. Because threads are relatively expensive to create in terms of memory and time, it is therefore recommended that your entry point function do a significant amount of work or set up a run loop to allow for recurring work to be performed. </p><p>For more information about the available threading technologies and how to use them, see <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2" data-renderer-version="1">Thread Management</a></span>.</p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW9" title="Run Loops"></a><h3 class="jump">Run Loops</h3><p>A run loop is a piece of infrastructure used to manage events arriving asynchronously on a thread. A run loop works by monitoring one or more event sources for the thread. As events arrive, the system wakes up the thread and dispatches the events to the run loop, which then dispatches them to the handlers you specify. If no events are present and ready to be handled, the run loop puts the thread to sleep. </p><p>You are not required to use a run loop with any threads you create but doing so can provide a better experience for the user. Run loops make it possible to create long-lived threads that use a minimal amount of resources. Because a run loop puts its thread to sleep when there is nothing to do, it eliminates the need for polling, which wastes CPU cycles and prevents the processor itself from sleeping and saving power. </p><p>To configure a run loop, all you have to do is launch your thread, get a reference to the run loop object, install your event handlers, and tell the run loop to run. The infrastructure provided by OS X handles the configuration of the main thread’s run loop for you automatically. If you plan to create long-lived secondary threads, however, you must configure the run loop for those threads yourself.</p><p>Details about run loops and examples of how to use them are provided in <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" data-renderer-version="1">Run Loops</a></span>. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW7" title="Synchronization Tools"></a><h3 class="jump">Synchronization Tools</h3><p>One of the hazards of threaded programming is resource contention among multiple threads. If multiple threads try to use or modify the same resource at the same time, problems can occur. One way to alleviate the problem is to eliminate the shared resource altogether and make sure each thread has its own distinct set of resources on which to operate. When maintaining completely separate resources is not an option though, you may have to synchronize access to the resource using locks, conditions, atomic operations, and other techniques. </p><p>Locks provide a brute force form of protection for code that can be executed by only one thread at a time. The most common type of lock is mutual exclusion lock, also known as a <em class="newTerm">mutex</em>. When a thread tries to acquire a mutex that is currently held by another thread, it blocks until the lock is released by the other thread. Several system frameworks provide support for mutex locks, although they are all based on the same underlying technology. In addition, Cocoa provides several variants of the mutex lock to support different types of behavior, such as recursion. For more information about the available types of locks, see <span class="content_text"><a href="../ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-126320" data-renderer-version="1">Locks</a></span>. </p><p>In addition to locks, the system provides support for conditions, which ensure the proper sequencing of tasks within your application. A condition acts as a gatekeeper, blocking a given thread until the condition it represents becomes true. When that happens, the condition releases the thread and allows it to continue. The POSIX layer and Foundation framework both provide direct support for conditions. (If you use operation objects, you can configure dependencies among your operation objects to sequence the execution of tasks, which is very similar to the behavior offered by conditions.)</p><p>Although locks and conditions are very common in concurrent design, atomic operations are another way to protect and synchronize access to data. Atomic operations offer a lightweight alternative to locks in situations where you can perform mathematical or logical operations on scalar data types. Atomic operations use special hardware instructions to ensure that modifications to a variable are completed before other threads have a chance to access it.</p><p>For more information about the available synchronization tools, see <span class="content_text"><a href="../ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-124887" data-renderer-version="1">Synchronization Tools</a></span>.  </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW10" title="Inter-thread Communication"></a><h3 class="jump">Inter-thread Communication</h3><p>Although a good design minimizes the amount of required communication, at some point, communication between threads becomes necessary. (A thread’s job is to do work for your application, but if the results of that job are never used, what good is it?) Threads may need to process new job requests or report their progress to your application’s main thread. In these situations, you need a way to get information from one thread to another. Fortunately, the fact that threads share the same process space means you have lots of options for communication.</p><p>There are many ways to communicate between threads, each with its own advantages and disadvantages. <span class="content_text">Configuring Thread-Local Storage</span> lists the most common communication mechanisms you can use in OS X. (With the exception of message queues and Cocoa distributed objects, these technologies are also available in iOS.) The techniques in this table are listed in order of increasing complexity.</p><a name="//apple_ref/doc/uid/10000057i-CH6-SW11" title="Table 1-3Communication mechanisms"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 1-3</strong>&nbsp;&nbsp;Communication mechanisms</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Mechanism</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p>Direct messaging</p></td><td ><p>Cocoa applications support the ability to perform selectors directly on other threads. This capability means that one thread can essentially execute a method on any other thread. Because they are executed in the context of the target thread, messages sent this way are automatically serialized on that thread. For information about input sources, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44" data-renderer-version="1">Cocoa Perform Selector Sources</a></span>. </p></td></tr><tr><td  scope="row"><p>Global variables, shared memory, and objects</p></td><td ><p>Another simple way to communicate information between two threads is to use a global variable, shared object, or shared block of memory. Although shared variables are fast and simple, they are also more fragile than direct messaging. Shared variables must be carefully protected with locks or other synchronization mechanisms to ensure the correctness of your code. Failure to do so could lead to race conditions, corrupted data, or crashes. </p></td></tr><tr><td  scope="row"><p>Conditions</p></td><td ><p>Conditions are a synchronization tool that you can use to control when a thread executes a particular portion of code. You can think of conditions as gate keepers, letting a thread run only when the stated condition is met. For information on how to use conditions, see <span class="content_text"><a href="../ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4" data-renderer-version="1">Using Conditions</a></span>. </p></td></tr><tr><td  scope="row"><p>Run loop sources</p></td><td ><p>A custom run loop source is one that you set up to receive application-specific messages on a thread. Because they are event driven, run loop sources put your thread to sleep automatically when there is nothing to do, which improves your thread’s efficiency. For information about run loops and run loop sources, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" data-renderer-version="1">Run Loops</a></span>. </p></td></tr><tr><td  scope="row"><p>Ports and sockets</p></td><td ><p>Port-based communication is a more elaborate way to communication between two threads, but it is also a very reliable technique. More importantly, ports and sockets can be used to communicate with external entities, such as other processes and services. For efficiency, ports are implemented using run loop sources, so your thread sleeps when there is no data waiting on the port. For information about run loops and about port-based input sources, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" data-renderer-version="1">Run Loops</a></span>. </p></td></tr><tr><td  scope="row"><p>Message queues</p></td><td ><p>The legacy Multiprocessing Services defines a first-in, first-out (FIFO) queue abstraction for managing incoming and outgoing data. Although message queues are simple and convenient, they are not as efficient as some other communications techniques. For more information about how to use message queues, see <em><!--a target="_self" -->Multiprocessing Services Programming Guide<!--/a--></em>.</p></td></tr><tr><td  scope="row"><p>Cocoa distributed objects</p></td><td ><p>Distributed objects is a Cocoa technology that provides a high-level implementation of port-based communications. Although it is possible to use this technology for inter-thread communication, doing so is highly discouraged because of the amount of overhead it incurs. Distributed objects is much more suitable for communicating with other processes, where the overhead of going between processes is already high. For more information, see <em><!--a target="_self" -->Distributed Objects Programming Topics<!--/a--></em>. </p></td></tr></table></div></section></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW18" title="Design Tips"></a><h2 class="jump">Design Tips</h2><p>The following sections offer guidelines to help you implement threads in a way that ensures the correctness of your code. Some of these guidelines also offer tips for achieving better performance with your own threaded code. As with any performance tips, you should always gather relevant performance statistics before, during, and after you make changes to your code. </p><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW17" title="Avoid Creating Threads Explicitly"></a><h3 class="jump">Avoid Creating Threads Explicitly</h3><p>Writing thread-creation code manually is tedious and potentially error-prone and you should avoid it whenever possible. OS X and iOS provide implicit support for concurrency through other APIs. Rather than create a thread yourself, consider using asynchronous APIs, GCD, or operation objects to do the work. These technologies do the thread-related work behind the scenes for you and are guaranteed to do it correctly. In addition, technologies such as GCD and operation objects are designed to manage threads much more efficiently than your own code ever could by adjusting the number of active threads based on the current system load. For more information about GCD and operation objects, see <em><a href="../../../../General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" data-renderer-version="1" target="_self">Concurrency Programming Guide</a></em>.  </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW20" title="Keep Your Threads Reasonably Busy"></a><h3 class="jump">Keep Your Threads Reasonably Busy</h3><p>If you decide to create and manage threads manually, remember that threads consume precious system resources. You should do your best to make sure that any tasks you assign to threads are reasonably long-lived and productive. At the same time, you should not be afraid to terminate threads that are spending most of their time idle. Threads use a nontrivial amount of memory, some of it wired, so releasing an idle thread not only helps reduce your application’s memory footprint, it also frees up more physical memory for other system processes to use.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/10000057i-CH6-DontLinkElementID_6" title="Important"></a><p><strong>Important:</strong>&nbsp;Before you start terminating idle threads, you should always record a set of baseline measurements of your applications current performance. After trying your changes, take additional measurements to verify that the changes are actually improving performance, rather than hurting it.</p><p></p></aside></div></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW19" title="Avoid Shared Data Structures"></a><h3 class="jump">Avoid Shared Data Structures</h3><p>The simplest and easiest way to avoid thread-related resource conflicts is to give each thread in your program its own copy of whatever data it needs. Parallel code works best when you minimize the communication and resource contention among your threads. </p><p>Creating a multithreaded application is hard. Even if you are very careful and lock shared data structures at all the right junctures in your code, your code may still be semantically unsafe. For example, your code could run into problems if it expected shared data structures to be modified in a specific order. Changing your code to a transaction-based model to compensate could subsequently negate the performance advantage of having multiple threads. Eliminating the resource contention in the first place often results in a simpler design with excellent performance. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW21" title="Threads and Your User Interface"></a><h3 class="jump">Threads and Your User Interface</h3><p>If your application has a graphical user interface, it is recommended that you receive user-related events and initiate interface updates from your application’s main thread. This approach helps avoid synchronization issues associated with handling user events and drawing window content. Some frameworks, such as Cocoa, generally require this behavior, but even for those that do not, keeping this behavior on the main thread has the advantage of simplifying the logic for managing your user interface.</p><p>There are a few notable exceptions where it is advantageous to perform graphical operations from other threads. For example, you can use secondary threads to create and process images and perform other image-related calculations. Using secondary threads for these operations can greatly increase performance. If you are not sure about a particular graphical operation though, plan on doing it from your main thread.</p><p>For more information about Cocoa thread safety, see <span class="content_text"><a href="../ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1" data-renderer-version="1">Thread Safety Summary</a></span>. For more information about drawing in Cocoa, see <em><a href="../../CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290" data-renderer-version="1" target="_self">Cocoa Drawing Guide</a></em>.</p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW16" title="Be Aware of Thread Behaviors at Quit Time"></a><h3 class="jump">Be Aware of Thread Behaviors at Quit Time</h3><p>A process runs until all non-detached threads have exited. By default, only the application’s main thread is created as non-detached, but you can create other threads that way as well. When the user quits an application, it is usually considered appropriate behavior to terminate all detached threads immediately, because the work done by detached threads is considered optional. If your application is using background threads to save data to disk or do other critical work, however, you may want to create those threads as non-detached to prevent the loss of data when the application exits.  </p><p>Creating threads as non-detached (also known as joinable) requires extra work on your part. Because most high-level thread technologies do not create joinable threads by default, you may have to use the POSIX API to create your thread. In addition, you must add code to your application’s main thread to join with the non-detached threads when they do finally exit. For information on creating joinable threads, see <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3" data-renderer-version="1">Setting the Detached State of a Thread</a></span>. </p><p>If you are writing a Cocoa application, you can also use the <code><a href="https://developer.apple.com/reference/appkit/nsapplicationdelegate/1428642-applicationshouldterminate" target="_self" class="urlLink">applicationShouldTerminate:</a></code> delegate method to delay the termination of the application until a later time or cancel it altogether. When delaying termination, your application would need to wait until any critical threads have finished their tasks and then invoke the <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428594-replytoapplicationshouldterminat" target="_self" class="urlLink">replyToApplicationShouldTerminate:</a></code> method. For more information on these methods, see <em><a href="https://developer.apple.com/reference/appkit/nsapplication" target="_self" class="urlLink">NSApplication Class Reference</a></em>. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW22" title="Handle Exceptions"></a><h3 class="jump">Handle Exceptions</h3><p>Exception handling mechanisms rely on the current call stack to perform any necessary clean up when an exception is thrown. Because each thread has its own call stack, each thread is therefore responsible for catching its own exceptions. Failing to catch an exception in a secondary thread is the same as failing to catch an exception in your main thread: the owning process is terminated. You cannot throw an uncaught exception to a different thread for processing.</p><p>If you need to notify another thread (such as the main thread) of an exceptional situation in the current thread, you should catch the exception and simply send a message to the other thread indicating what happened. Depending on your model and what you are trying to do, the thread that caught the exception can then continue processing (if that is possible), wait for instructions, or simply exit. </p><div class="notebox"><aside><a name="//apple_ref/doc/uid/10000057i-CH6-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;In Cocoa, an <code>NSException</code> object is a self-contained object that can be passed from thread to thread once it has been caught. </p><p></p></aside></div><p>In some cases, an exception handler may be created for you automatically. For example, the <code>@synchronized</code> directive in Objective-C contains an implicit exception handler.</p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW24" title="Terminate Your Threads Cleanly"></a><h3 class="jump">Terminate Your Threads Cleanly</h3><p>The best way for a thread to exit is naturally, by letting it reach the end of its main entry point routine. Although there are functions to terminate threads immediately, those functions should be used only as a last resort. Terminating a thread before it has reached its natural end point prevents the thread from cleaning up after itself. If the thread has allocated memory, opened a file, or acquired other types of resources, your code may be unable to reclaim those resources, resulting in memory leaks or other potential problems. </p><p>For more information on the proper way to exit a thread, see <span class="content_text"><a href="../CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW10" data-renderer-version="1">Terminating a Thread</a></span>. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH6-SW23" title="Thread Safety in Libraries"></a><h3 class="jump">Thread Safety in Libraries</h3><p>Although an application developer has control over whether an application executes with multiple threads, library developers do not. When developing libraries, you must assume that the calling application is multithreaded or could switch to being multithreaded at any time. As a result, you should always use locks for critical sections of code.</p><p>For library developers, it is unwise to create locks only when an application becomes multithreaded. If you need to lock your code at some point, create the lock object early in the use of your library, preferably in some sort of explicit call to initialize the library. Although you could also use a static library initialization function to create such locks, try to do so only when there is no other way. Execution of an initialization function adds to the time required to load your library and could adversely affect performance.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/10000057i-CH6-SW27" title="Note"></a><p><strong>Note:</strong>&nbsp;Always remember to balance calls to lock and unlock a mutex lock within your library. You should also remember to lock library data structures rather than rely on the calling code to provide a thread-safe environment.</p><p></p></aside></div><p>If you are developing a Cocoa library, you can register as an observer for the <code><a href="https://developer.apple.com/reference/foundation/nsnotification.name/1417567-nswillbecomemultithreaded" target="_self" class="urlLink">NSWillBecomeMultiThreadedNotification</a></code> if you want to be notified when the application becomes multithreaded. You should not rely on receiving this notification, though, as it might be dispatched before your library code is ever called.</p></section></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../CreatingThreads/CreatingThreads.html'>Next</a><a class='previousLink' rel='prev' href='../Introduction/Introduction.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2014 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2014-07-15</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1260/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/feedback.js"></script>
</body>
</html>
