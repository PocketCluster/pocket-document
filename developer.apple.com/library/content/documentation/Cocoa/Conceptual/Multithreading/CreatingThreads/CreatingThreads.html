<!DOCTYPE html>
<html lang="en">
<head>
    <title>Thread Management</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/10000057i">
    <meta id="document-version" name="document-version" content="5.6.3">
    <meta id="build" name="build" content="ded95564c405529dbbbe590063edd114" />
    <meta id="chapterId" name="chapterId" content="10000057i-CH15">
    <meta id="date" name="date" content="2014-07-15">
    <meta id="description" name="description" content="Explains how to use threads in Cocoa applications.">
    <meta id="book-title" name="book-title" content="Threading Programming Guide">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="Mac Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/mac">
    <meta id="reflib" name="reflib" content="Guides and Sample Code">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Performance}">
    
    
    <meta id="copyright" name="copyright" content="Copyright 2017 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Threading Programming Guide: Thread Management">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1260">
    <link id="book-index-page" rel="Start" title="Threading Programming Guide" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../RunLoopManagement/RunLoopManagement.html">
    <link id="previous-page" rel="Prev" type="text/html" href="../AboutThreads/AboutThreads.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/feedback.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta id="platforms" name="platforms" content="">
</head>    
<body><a name="//apple_ref/doc/uid/10000057i-CH15" title="Thread Management"></a>
    <div id="_omniture_top">
    <!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
    <script type="text/javascript">
    /* RSID: */
    var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
    </script>

    <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
    <script type="text/javascript">
    s.pageName=AC.Tracking.pageName();
    s.channel="www.us.developer"

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)</script>
    <!-- End SiteCatalyst code version: H.8. -->
    </div>

    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode unified">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>Guides and Sample Code</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search Guides and Sample Code</label>
            
            
    
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Threading Programming Guide</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../RunLoopManagement/RunLoopManagement.html'>Next</a><a class='previousLink' rel='prev' href='../AboutThreads/AboutThreads.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/10000057i-CH15-SW2" title="Thread Management"></a><h1 id="pageTitle">Thread Management</h1><p>Each process (application) in OS X or iOS is made up of one or more threads, each of which represents a single path of execution through the application's code. Every application starts with a single thread, which runs the application's <code>main</code> function. Applications can spawn additional threads, each of which executes the code of a specific function.</p><p>When an application spawns a new thread, that thread becomes an independent entity inside of the application's process space. Each thread has its own execution stack and is scheduled for runtime separately by the kernel. A thread can communicate with other threads and other processes, perform I/O operations, and do anything else you might need it to do. Because they are inside the same process space, however, all threads in a single application share the same virtual memory space and have the same access rights as the process itself. </p><p>This chapter provides an overview of the thread technologies available in OS X and iOS along with examples of how to use those technologies in your applications. </p><div class="notebox"><aside><a name="//apple_ref/doc/uid/10000057i-CH15-SW18" title="Note"></a><p><strong>Note:</strong>&nbsp;For a historical look at the threading architecture of Mac OS, and for additional background information on threads, see Technical Note TN2028, “Threading Architectures”. </p><p></p></aside></div><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW7" title="Thread Costs"></a><h2 class="jump">Thread Costs</h2><p>Threading has a real cost to your program (and the system) in terms of memory use and performance. Each thread requires the allocation of memory in both the kernel memory space and your program’s memory space. The core structures needed to manage your thread and coordinate its scheduling are stored in the kernel using wired memory. Your thread’s stack space and per-thread data is stored in your program’s memory space. Most of these structures are created and initialized when you first create the thread—a process that can be relatively expensive because of the required interactions with the kernel.  </p><p><span class="content_text">Table 2-1</span> quantifies the approximate costs associated with creating a new user-level thread in your application. Some of these costs are configurable, such as the amount of stack space allocated for secondary threads. The time cost for creating a thread is a rough approximation and should be used only for relative comparisons with each other. Thread creation times can vary greatly depending on processor load, the speed of the computer, and the amount of available system and program memory.</p><a name="//apple_ref/doc/uid/10000057i-CH15-SW5" title="Table 2-1Thread creation costs"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 2-1</strong>&nbsp;&nbsp;Thread creation costs</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Item</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Approximate cost</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Notes</p></th></tr><tr><td  scope="row"><p>Kernel data structures</p></td><td ><p>Approximately 1 KB</p></td><td ><p>This memory is used to store the thread data structures and attributes, much of which is allocated as wired memory and therefore cannot be paged to disk.<a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_10"></a></p></td></tr><tr><td  scope="row"><p>Stack space</p></td><td ><p>512 KB (secondary threads)</p><p>8 MB (OS X main thread)</p><p>1 MB (iOS main thread)</p></td><td ><p>The minimum allowed stack size for secondary threads is 16 KB and the stack size must be a multiple of 4 KB. The space for this memory is set aside in your process space at thread creation time, but the actual pages associated with that memory are not created until they are needed. <a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_11"></a><a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_12"></a></p></td></tr><tr><td  scope="row"><p>Creation time</p></td><td ><p>Approximately 90 microseconds</p></td><td ><p>This value reflects the time between the initial call to create the thread and the time at which the thread’s entry point routine began executing. The figures were determined by analyzing the mean and median values generated during thread creation on an Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5.</p></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/10000057i-CH15-SW28" title="Note"></a><p><strong>Note:</strong>&nbsp;Because of their underlying kernel support, operation objects can often create threads more quickly. Rather than creating threads from scratch every time, they use pools of threads already residing in the kernel to save on allocation time. For more information about using operation objects, see <em><a href="../../../../General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" data-renderer-version="1" target="_self">Concurrency Programming Guide</a></em>.  </p><p></p></aside></div><p>Another cost to consider when writing threaded code is the production costs. Designing a threaded application can sometimes require fundamental changes to the way you organize your application’s data structures. Making those changes might be necessary to avoid the use of synchronization, which can itself impose a tremendous performance penalty on poorly designed applications. Designing those data structures, and debugging problems in threaded code, can increase the time it takes to develop a threaded application. Avoiding those costs can create bigger problems at runtime, however, if your threads spend too much time waiting on locks or doing nothing.</p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW19" title="Creating a Thread"></a><h2 class="jump">Creating a Thread</h2><p>Creating low-level threads is relatively simple. In all cases, you must have a function or method to act as your thread’s main entry point and you must use one of the available thread routines to start your thread. The following sections show the basic creation process for the more commonly used thread technologies. Threads created using these techniques inherit a default set of attributes, determined by the technology you use. For information on how to configure your threads, see <span class="content_text"><a href="#//apple_ref/doc/uid/10000057i-CH15-SW8" data-renderer-version="1">Configuring Thread Attributes</a></span>.  </p><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW11" title="Using NSThread"></a><h3 class="jump">Using NSThread</h3><p>There are two ways to create a thread using the <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> class:</p><ul class="ul"><li class="li"><p>Use the <code><a href="https://developer.apple.com/reference/foundation/thread/1415633-detachnewthreadselector" target="_self" class="urlLink">detachNewThreadSelector:toTarget:withObject:</a></code> class method to spawn the new thread.</p></li><li class="li"><p>Create a new <code>NSThread</code> object and call its <code>start</code> method. (Supported only in iOS and OS X v10.5 and later.)</p></li></ul><p>Both techniques create a detached thread in your application. A detached thread means that the thread’s resources are automatically reclaimed by the system when the thread exits. It also means that your code does not have to join explicitly with the thread later. </p><p>Because the <code>detachNewThreadSelector:toTarget:withObject:</code> method is supported in all versions of OS X, it is often found in existing Cocoa applications that use threads. To detach a new thread, you simply provide the name of the method (specified as a selector) that you want to use as the thread’s entry point, the object that defines that method, and any data you want to pass to the thread at startup. The following example shows a basic invocation of this method that spawns a thread using a custom method of the current object.  </p><div class="codesample clear"><table><tr><td scope="row"><pre>[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];<span></span></pre></td></tr></table></div><p>Prior to OS X v10.5, you used the <code>NSThread</code> class primarily to spawn threads. Although you could get an <code>NSThread</code> object and access some thread attributes, you could only do so from the thread itself after it was running. In OS X v10.5, support was added for creating <code>NSThread</code> objects without immediately spawning the corresponding new thread. (This support is also available in iOS.) This support made it possible to get and set various thread attributes prior to starting the thread. It also made it possible to use that thread object to refer to the running thread later.  </p><p>The simple way to initialize an <code>NSThread</code> object in OS X v10.5 and later is to use the <code><a href="https://developer.apple.com/reference/foundation/nsthread/1414773-initwithtarget" target="_self" class="urlLink">initWithTarget:selector:object:</a></code> method. This method takes the exact same information as the <code>detachNewThreadSelector:toTarget:withObject:</code> method and uses it to initialize a new <code>NSThread</code> instance. It does not start the thread, however. To start the thread, you call the thread object’s <code>start</code> method explicitly, as shown in the following example: </p><div class="codesample clear"><table><tr><td scope="row"><pre>NSThread* myThread = [[NSThread alloc] initWithTarget:self<span></span></pre></td></tr><tr><td scope="row"><pre>                                        selector:@selector(myThreadMainMethod:)<span></span></pre></td></tr><tr><td scope="row"><pre>                                        object:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>[myThread start];  // Actually create the thread<span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/10000057i-CH15-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;An alternative to using the <code>initWithTarget:selector:object:</code> method is to subclass <code>NSThread</code> and override its <code>main</code> method. You would use the overridden version of this method to implement your thread’s main entry point. For more information, see the subclassing notes in <em><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread Class Reference</a></em>. </p><p></p></aside></div><p>If you have an <code>NSThread</code> object whose thread is currently running, one way you can send messages to that thread is to use the <code><a href="https://developer.apple.com/reference/objectivec/nsobject/1414476-perform" target="_self" class="urlLink">performSelector:onThread:withObject:waitUntilDone:</a></code> method of almost any object in your application. Support for performing selectors on threads (other than the main thread) was introduced in OS X v10.5 and is a convenient way to communicate between threads. (This support is also available in iOS.) The messages you send using this technique are executed directly by the other thread as part of its normal run-loop processing. (Of course, this does mean that the target thread has to be running in its run loop; see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" data-renderer-version="1">Run Loops</a></span>.) You may still need some form of synchronization when you communicate this way, but it is simpler than setting up communications ports between the threads. </p><div class="notebox"><aside><a name="//apple_ref/doc/uid/10000057i-CH15-SW30" title="Note"></a><p><strong>Note:</strong>&nbsp;Although good for occasional communication between threads, you should not use the  <code>performSelector:onThread:withObject:waitUntilDone:</code> method for time critical or frequent communication between threads. </p><p></p></aside></div><p>For a list of other thread communication options, see <span class="content_text"><a href="#//apple_ref/doc/uid/10000057i-CH15-SW3" data-renderer-version="1">Setting the Detached State of a Thread</a></span>. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW12" title="Using POSIX Threads"></a><h3 class="jump">Using POSIX Threads</h3><p>OS X and iOS provide C-based support for creating threads using the POSIX thread API. This technology can actually be used in any type of application (including Cocoa and Cocoa Touch applications) and might be more convenient if you are writing your software for multiple platforms. The POSIX routine you use to create threads is called, appropriately enough, <code>pthread_create</code>. </p><p><span class="content_text">Listing 2-1</span> shows two custom functions for creating a thread using POSIX calls. The <code>LaunchThread</code> function creates a new thread whose main routine is implemented in the <code>PosixThreadMainRoutine</code> function. Because POSIX creates threads as joinable by default, this example changes the thread’s attributes to create a detached thread. Marking the thread as detached gives the system a chance to reclaim the resources for that thread immediately when it exits.  </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW6" title="Listing 2-1Creating a thread in C"></a><p class="codesample clear"><strong class="caption_number">Listing 2-1</strong>&nbsp;&nbsp;Creating a thread in C</p><div class="codesample clear"><table><tr><td scope="row"><pre>#include &lt;assert.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;pthread.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void* PosixThreadMainRoutine(void* data)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Do some work here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void LaunchThread()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the thread using POSIX routines.<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_attr_t  attr;<span></span></pre></td></tr><tr><td scope="row"><pre>    pthread_t       posixThreadID;<span></span></pre></td></tr><tr><td scope="row"><pre>    int             returnVal;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    returnVal = pthread_attr_init(&amp;attr);<span></span></pre></td></tr><tr><td scope="row"><pre>    assert(!returnVal);<span></span></pre></td></tr><tr><td scope="row"><pre>    returnVal = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<span></span></pre></td></tr><tr><td scope="row"><pre>    assert(!returnVal);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    int     threadError = pthread_create(&amp;posixThreadID, &amp;attr, &amp;PosixThreadMainRoutine, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    returnVal = pthread_attr_destroy(&amp;attr);<span></span></pre></td></tr><tr><td scope="row"><pre>    assert(!returnVal);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (threadError != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>         // Report an error.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you add the code from the preceding listing to one of your source files and call the <code>LaunchThread</code> function, it would create a new detached thread in your application. Of course, new threads created using this code would not do anything useful. The threads would launch and almost immediately exit. To make things more interesting, you would need to add code to the <code>PosixThreadMainRoutine</code> function to do some actual work. To ensure that a thread knows what work to do, you can pass it a pointer to some data at creation time. You pass this pointer as the last parameter of the <code>pthread_create</code> function. </p><p>To communicate information from your newly created thread back to your application’s main thread, you need to establish a communications path between the target threads. For C-based applications, there are several ways to communicate between threads, including the use of ports, conditions, or shared memory. For long-lived threads, you should almost always set up some sort of inter-thread communications mechanism to give your application’s main thread a way to check the status of the thread or shut it down cleanly when the application exits. </p><p>For more information about POSIX thread functions, see the <code><!--a target="_self" -->pthread<!--/a--></code> man page. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW13" title="Using NSObject to Spawn a Thread"></a><h3 class="jump">Using NSObject to Spawn a Thread</h3><p>In iOS and OS X v10.5 and later, all objects have the ability to spawn a new thread and use it to execute one of their methods. The <code><a href="https://developer.apple.com/reference/objectivec/nsobject/1412390-performselectorinbackground" target="_self" class="urlLink">performSelectorInBackground:withObject:</a></code> method creates a new detached thread and uses the specified method as the entry point for the new thread. For example, if you have some object (represented by the variable <code>myObj</code>) and that object has a method called <code>doSomething</code> that you want to run in a background thread, you could use the following code to do that: </p><div class="codesample clear"><table><tr><td scope="row"><pre>[myObj performSelectorInBackground:@selector(doSomething) withObject:nil];<span></span></pre></td></tr></table></div><p>The effect of calling this method is the same as if you called the <code><a href="https://developer.apple.com/reference/foundation/thread/1415633-detachnewthreadselector" target="_self" class="urlLink">detachNewThreadSelector:toTarget:withObject:</a></code> method of <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> with the current object, selector, and parameter object as parameters. The new thread is spawned immediately using the default configuration and begins running. Inside the selector, you must configure the thread just as you would any thread. For example, you would need to set up an autorelease pool (if you were not using garbage collection) and configure the thread’s run loop if you planned to use it. For information on how to configure new threads, see <span class="content_text"><a href="#//apple_ref/doc/uid/10000057i-CH15-SW8" data-renderer-version="1">Configuring Thread Attributes</a></span>. </p></section><section><a name="//apple_ref/doc/uid/20000738-125024" title="Using POSIX Threads in a Cocoa Application"></a><a name="//apple_ref/doc/uid/10000057i-CH15-125024-BAJGFJED" title="Using POSIX Threads in a Cocoa Application"></a><h3 class="jump">Using POSIX Threads in a Cocoa Application</h3><p>Although the <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> class is the main interface for creating threads in Cocoa applications, you are free to use POSIX threads instead if doing so is more convenient for you. For example, you might use POSIX threads if you already have code that uses them and you do not want to rewrite it. If you do plan to use the POSIX threads in a Cocoa application, you should still be aware of the interactions between Cocoa and threads and obey the guidelines in the following sections.  </p><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW21" title="Protecting the Cocoa Frameworks"></a><h4 class="jump">Protecting the Cocoa Frameworks</h4><p>For multithreaded applications, Cocoa frameworks use locks and other forms of internal synchronization to ensure they behave correctly. To prevent these locks from degrading performance in the single-threaded case, however, Cocoa does not create them until the application spawns its first new thread using the <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> class. If you spawn threads using only POSIX thread routines, Cocoa does not receive the notifications it needs to know that your application is now multithreaded. When that happens, operations involving the Cocoa frameworks may destabilize or crash your application. </p><p>To let Cocoa know that you intend to use multiple threads, all you have to do is spawn a single thread using the <code>NSThread</code> class and let that thread immediately exit. Your thread entry point need not do anything. Just the act of spawning a thread using <code>NSThread</code> is enough to ensure that the locks needed by the Cocoa frameworks are put in place. </p><p>If you are not sure if Cocoa thinks your application is multithreaded or not, you can use the <code><a href="https://developer.apple.com/reference/foundation/nsthread/1410702-ismultithreaded" target="_self" class="urlLink">isMultiThreaded</a></code> method of <code>NSThread</code> to check. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW23" title="Mixing POSIX and Cocoa Locks"></a><h4 class="jump">Mixing POSIX and Cocoa Locks</h4><p>It is safe to use a mixture of POSIX and Cocoa locks inside the same application. Cocoa lock and condition objects are essentially just wrappers for POSIX mutexes and conditions. For a given lock, however, you must always use the same interface to create and manipulate that lock. In other words, you cannot use a Cocoa <code><a href="https://developer.apple.com/reference/foundation/nslock" target="_self" class="urlLink">NSLock</a></code> object to manipulate a mutex you created using the <code><!--a target="_self" -->pthread_mutex_init<!--/a--></code> function, and vice versa.</p></section></section></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW8" title="Configuring Thread Attributes"></a><h2 class="jump">Configuring Thread Attributes</h2><p>After you create a thread, and sometimes before, you may want to configure different portions of the thread environment. The following sections describe some of the changes you can make and when you might make them. </p><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW24" title="Configuring the Stack Size of a Thread"></a><h3 class="jump">Configuring the Stack Size of a Thread</h3><p>For each new thread you create, the system allocates a specific amount of memory in your process space to act as the stack for that thread. The stack manages the stack frames and is also where any local variables for the thread are declared. The amount of memory allocated for threads is listed in <span class="content_text"><a href="#//apple_ref/doc/uid/10000057i-CH15-SW7" data-renderer-version="1">Thread Costs</a></span>. </p><p>If you want to change the stack size of a given thread, you must do so before you create the thread. All of the threading technologies provide some way of setting the stack size, although setting the stack size using <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> is available only in iOS and OS X v10.5 and later. <span class="content_text">Table 2-2</span> lists the different options for each technology. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW9" title="Table 2-2Setting the stack size of a thread"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 2-2</strong>&nbsp;&nbsp;Setting the stack size of a thread</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Technology</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Option</p></th></tr><tr><td  scope="row"><p>Cocoa</p></td><td ><p>In iOS and OS X v10.5 and later, allocate and initialize an <code>NSThread</code> object (do not use the <code><a href="https://developer.apple.com/reference/foundation/thread/1415633-detachnewthreadselector" target="_self" class="urlLink">detachNewThreadSelector:toTarget:withObject:</a></code> method). Before calling the <code>start</code> method of the thread object, use the <code><a href="https://developer.apple.com/reference/foundation/thread/1415190-stacksize" target="_self" class="urlLink">setStackSize:</a></code> method to specify the new stack size. </p></td></tr><tr><td  scope="row"><p>POSIX</p></td><td ><p>Create a new <code>pthread_attr_t</code> structure and use the <code>pthread_attr_setstacksize</code> function to change the default stack size. Pass the attributes to the <code>pthread_create</code> function when creating your thread. </p></td></tr><tr><td  scope="row"><p>Multiprocessing Services</p></td><td ><p>Pass the appropriate stack size value to the <code><a href="https://developer.apple.com/reference/coreservices/1585779-mpcreatetask" target="_self" class="urlLink">MPCreateTask</a></code> function when you create your thread. </p></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW4" title="Configuring Thread-Local Storage"></a><h3 class="jump">Configuring Thread-Local Storage</h3><p>Each thread maintains a dictionary of key-value pairs that can be accessed from anywhere in the thread. You can use this dictionary to store information that you want to persist throughout the execution of your thread. For example, you could use it to store state information that you want to persist through multiple iterations of your thread’s run loop. </p><p>Cocoa and POSIX store the thread dictionary in different ways, so you cannot mix and match calls to the two technologies. As long as you stick with one technology inside your thread code, however, the end results should be similar. In Cocoa, you use the <code><a href="https://developer.apple.com/reference/foundation/thread/1411433-threaddictionary" target="_self" class="urlLink">threadDictionary</a></code> method of an <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> object to retrieve an <code>NSMutableDictionary</code> object, to which you can add any keys required by your thread. In POSIX, you use the <code>pthread_setspecific</code> and <code>pthread_getspecific</code> functions to set and get the keys and values of your thread. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW3" title="Setting the Detached State of a Thread"></a><h3 class="jump">Setting the Detached State of a Thread</h3><p>Most high-level thread technologies create detached threads by default. In most cases, detached threads are preferred because they allow the system to free up the thread’s data structures immediately upon completion of the thread. Detached threads also do not require explicit interactions with your program. The means of retrieving results from the thread is left to your discretion. By comparison, the system does not reclaim the resources for joinable threads until another thread explicitly joins with that thread, a process which may block the thread that performs the join. </p><p>You can think of joinable threads as akin to child threads. Although they still run as independent threads, a joinable thread must be joined by another thread before its resources can be reclaimed by the system. Joinable threads also provide an explicit way to pass data from an exiting thread to another thread. Just before it exits, a joinable thread can pass a data pointer or other return value to the <code>pthread_exit</code> function. Another thread can then claim this data by calling the <code>pthread_join</code> function. </p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_7" title="Important"></a><p><strong>Important:</strong>&nbsp;At application exit time, detached threads can be terminated immediately but joinable threads cannot. Each joinable thread must be joined before the process is allowed to exit. Joinable threads may therefore be preferable in cases where the thread is doing critical work that should not be interrupted, such as saving data to disk. </p><p></p></aside></div><p>If you do want to create joinable threads, the only way to do so is using POSIX threads. POSIX creates threads as joinable by default. To mark a thread as detached or joinable, modify the thread attributes using the <code>pthread_attr_setdetachstate</code> function prior to creating the thread. After the thread begins, you can change a joinable thread to a detached thread by calling the <code>pthread_detach</code> function. For more information about these POSIX thread functions, see the <code><!--a target="_self" -->pthread<!--/a--></code> man page. For information on how to join with a thread, see the <code><!--a target="_self" -->pthread_join<!--/a--></code> man page.</p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW26" title="Setting the Thread Priority"></a><h3 class="jump">Setting the Thread Priority</h3><p>Any new thread you create has a default priority associated with it. The kernel’s scheduling algorithm takes thread priorities into account when determining which threads to run, with higher priority threads being more likely to run than threads with lower priorities. Higher priorities do not guarantee a specific amount of execution time for your thread, just that it is more likely to be chosen by the scheduler when compared to lower-priority threads. </p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/10000057i-CH15-DontLinkElementID_8" title="Important"></a><p><strong>Important:</strong>&nbsp;It is generally a good idea to leave the priorities of your threads at their default values. Increasing the priorities of some threads also increases the likelihood of starvation among lower-priority threads. If your application contains high-priority and low-priority threads that must interact with each other, the starvation of lower-priority threads may block other threads and create performance bottlenecks.</p><p></p></aside></div><p>If you do want to modify thread priorities, both Cocoa and POSIX provide a way to do so. For Cocoa threads, you can use the <code><a href="https://developer.apple.com/reference/foundation/nsthread/1407523-setthreadpriority" target="_self" class="urlLink">setThreadPriority:</a></code> class method of <code><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread</a></code> to set the priority of the currently running thread. For POSIX threads, you use the <code>pthread_setschedparam</code> function. For more information, see <em><a href="https://developer.apple.com/reference/foundation/nsthread" target="_self" class="urlLink">NSThread Class Reference</a></em> or <code><!--a target="_self" -->pthread_setschedparam<!--/a--></code> man page.</p></section></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW16" title="Writing Your Thread Entry Routine"></a><h2 class="jump">Writing Your Thread Entry Routine</h2><p>For the most part, the structure of your thread’s entry point routines is the same in OS X as it is on other platforms. You initialize your data structures, do some work or optionally set up a run loop, and clean up when your thread’s code is done. Depending on your design, there may be some additional steps you need to take when writing your entry routine. </p><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW17" title="Creating an Autorelease Pool"></a><h3 class="jump">Creating an Autorelease Pool</h3><p>Applications that link in Objective-C frameworks typically must create at least one autorelease pool in each of their threads. If an application uses the managed model—where the application handles the retaining and releasing of objects—the autorelease pool catches any objects that are autoreleased from that thread. </p><p>If an application uses garbage collection instead of the managed memory model, creation of an autorelease pool is not strictly necessary. The presence of an autorelease pool in a garbage-collected application is not harmful, and for the most part is simply ignored. It is allowed for cases where a code module must support both garbage collection and the managed memory model. In such a case, the autorelease pool must be present to support the managed memory model code and is simply ignored if the application is run with garbage collection enabled.</p><p>If your application uses the managed memory model, creating an autorelease pool should be the first thing you do in your thread entry routine. Similarly, destroying this autorelease pool should be the last thing you do in your thread. This pool ensures that autoreleased objects are caught, although it does not release them until the thread itself exits. <span class="content_text">Listing 2-2</span> shows the structure of a basic thread entry routine that uses an autorelease pool.</p><a name="//apple_ref/doc/uid/10000057i-CH15-SW1" title="Listing 2-2Defining your thread entry point routine"></a><p class="codesample clear"><strong class="caption_number">Listing 2-2</strong>&nbsp;&nbsp;Defining your thread entry point routine</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)myThreadMainRoutine<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // Top-level pool<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Do thread work here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];  // Release the objects in the pool.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Because the top-level autorelease pool does not release its objects until the thread exits, long-lived threads should create additional autorelease pools to free objects more frequently. For example, a thread that uses a run loop might create and release an autorelease pool each time through that run loop. Releasing objects more frequently prevents your application’s memory footprint from growing too large, which can lead to performance problems. As with any performance-related behavior though, you should measure the actual performance of your code and tune your use of autorelease pools appropriately.</p><p>For more information on memory management and autorelease pools, see <em><a href="../../MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" data-renderer-version="1" target="_self">Advanced Memory Management Programming Guide</a></em>. </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW22" title="Setting Up an Exception Handler"></a><h3 class="jump">Setting Up an Exception Handler</h3><p>If your application catches and handles exceptions, your thread code should be prepared to catch any exceptions that might occur. Although it is best to handle exceptions at the point where they might occur, failure to catch a thrown exception in a thread causes your application to exit. Installing a final try/catch in your thread entry routine allows you to catch any unknown exceptions and provide an appropriate response. </p><p>You can use either the C++ or Objective-C exception handling style when building your project in Xcode. For information about setting how to raise and catch exceptions in Objective-C, see <em><a href="../../Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i" data-renderer-version="1" target="_self">Exception Programming Topics</a></em>.  </p></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW25" title="Setting Up a Run Loop"></a><h3 class="jump">Setting Up a Run Loop</h3><p>When writing code you want to run on a separate thread, you have two options. The first option is to write the code for a thread as one long task to be performed with little or no interruption, and have the thread exit when it finishes. The second option is put your thread into a loop and have it process requests dynamically as they arrive. The first option requires no special setup for your code; you just start doing the work you want to do. The second option, however, involves setting up your thread’s run loop. </p><p>OS X and iOS provide built-in support for implementing run loops in every thread. The app frameworks start the run loop of your application’s main thread automatically. If you create any secondary threads, you must configure the run loop and start it manually. </p><p>For information on using and configuring run loops, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" data-renderer-version="1">Run Loops</a></span>. </p></section></section><section><a name="//apple_ref/doc/uid/10000057i-CH15-SW10" title="Terminating a Thread"></a><h2 class="jump">Terminating a Thread</h2><p>The recommended way to exit a thread is to let it exit its entry point routine normally. Although Cocoa, POSIX, and Multiprocessing Services offer routines for killing threads directly, the use of such routines is strongly discouraged. Killing a thread prevents that thread from cleaning up after itself. Memory allocated by the thread could potentially be leaked and any other resources currently in use by the thread might not be cleaned up properly, creating potential problems later. </p><p>If you anticipate the need to terminate a thread in the middle of an operation, you should design your threads from the outset to respond to a cancel or exit message. For long-running operations, this might mean stopping work periodically and checking to see if such a message arrived. If a message does come in asking the thread to exit, the thread would then have the opportunity to perform any needed cleanup and exit gracefully; otherwise, it could simply go back to work and process the next chunk of data.</p><p>One way to respond to cancel messages is to use a run loop input source to receive such messages. <span class="content_text">Listing 2-3</span> shows the structure of how this code might look in your thread’s main entry routine. (The example shows the main loop portion only and does not include the steps for setting up an autorelease pool or configuring the actual work to do.) The example installs a custom input source on the run loop that presumably can be messaged from another one of your threads; for information on setting up input sources, see <span class="content_text"><a href="../RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7" data-renderer-version="1">Configuring Run Loop Sources</a></span>. After performing a portion of the total amount of work, the thread runs the run loop briefly to see if a message arrived on the input source. If not, the run loop exits immediately and the loop continues with the next chunk of work. Because the handler does not have direct access to the <code>exitNow</code> local variable, the exit condition is communicated through a key-value pair in the thread dictionary. </p><a name="//apple_ref/doc/uid/10000057i-CH15-SW15" title="Listing 2-3Checking for an exit condition during a long job"></a><p class="codesample clear"><strong class="caption_number">Listing 2-3</strong>&nbsp;&nbsp;Checking for an exit condition during a long job</p><div class="codesample clear"><table><tr><td scope="row"><pre>- (void)threadMainRoutine<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL moreWorkToDo = YES;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL exitNow = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRunLoop* runLoop = [NSRunLoop currentRunLoop];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add the exitNow BOOL to the thread dictionary.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary];<span></span></pre></td></tr><tr><td scope="row"><pre>    [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@"ThreadShouldExitNow"];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Install an input source.<span></span></pre></td></tr><tr><td scope="row"><pre>    [self myInstallCustomInputSource];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (moreWorkToDo &amp;&amp; !exitNow)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Do one chunk of a larger body of work here.<span></span></pre></td></tr><tr><td scope="row"><pre>        // Change the value of the moreWorkToDo Boolean when done.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Run the run loop but timeout immediately if the input source isn't waiting to fire.<span></span></pre></td></tr><tr><td scope="row"><pre>        [runLoop runUntilDate:[NSDate date]];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Check to see if an input source handler changed the exitNow value.<span></span></pre></td></tr><tr><td scope="row"><pre>        exitNow = [[threadDict valueForKey:@"ThreadShouldExitNow"] boolValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../RunLoopManagement/RunLoopManagement.html'>Next</a><a class='previousLink' rel='prev' href='../AboutThreads/AboutThreads.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2014 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2014-07-15</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1260/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/feedback.js"></script>
</body>
</html>
