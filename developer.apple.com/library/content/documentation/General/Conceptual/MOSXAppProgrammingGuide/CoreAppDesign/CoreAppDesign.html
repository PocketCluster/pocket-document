<!DOCTYPE html>
<html lang="en">
<head>
    <title>The Core App Design</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40010543">
    <meta id="document-version" name="document-version" content="5.2.0">
    <meta id="build" name="build" content="ded95564c405529dbbbe590063edd114" />
    <meta id="chapterId" name="chapterId" content="TP40010543-CH3">
    <meta id="date" name="date" content="2015-03-09">
    <meta id="description" name="description" content="Introduces the development process for Mac apps.">
    <meta id="book-title" name="book-title" content="Mac App Programming Guide">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="Mac Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/mac">
    <meta id="reflib" name="reflib" content="Guides and Sample Code">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Technologies/Cocoa Layer/AppKit}, {Topic/General}">
    
    
    <meta id="copyright" name="copyright" content="Copyright 2017 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Mac App Programming Guide: The Core App Design">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1260">
    <link id="book-index-page" rel="Start" title="Mac App Programming Guide" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="../FullScreenApp/FullScreenApp.html">
    <link id="previous-page" rel="Prev" type="text/html" href="../AppRuntime/AppRuntime.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/feedback.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta id="platforms" name="platforms" content="">
</head>    
<body><a name="//apple_ref/doc/uid/TP40010543-CH3" title="The Core App Design"></a>
    <div id="_omniture_top">
    <!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
    <script type="text/javascript">
    /* RSID: */
    var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
    </script>

    <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
    <script type="text/javascript">
    s.pageName=AC.Tracking.pageName();
    s.channel="www.us.developer"

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)</script>
    <!-- End SiteCatalyst code version: H.8. -->
    </div>

    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode unified">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>Guides and Sample Code</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search Guides and Sample Code</label>
            
            
    
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Mac App Programming Guide</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../FullScreenApp/FullScreenApp.html'>Next</a><a class='previousLink' rel='prev' href='../AppRuntime/AppRuntime.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/TP40010543-CH3-SW1" title="The Core App Design"></a><h1 id="pageTitle">The Core App Design</h1><p>To unleash the power of OS X, you develop apps using the Cocoa application environment. Cocoa presents the app’s user interface and integrates it tightly with the other components of the operating system. Cocoa provides an integrated suite of object-oriented software components packaged in two core class libraries, the AppKit and Foundation <span class="pediaLink" data-header="Framework" data-contents="A framework is a bundle (a structured directory) that contains a dynamic shared library along with associated resources, such as nib files, image files, and header files. "><a href="../../DevPedia-CocoaCore/Framework.html#//apple_ref/doc/uid/TP40008195-CH56" data-renderer-version="1" target="_self">frameworks</a></span>, and a number of underlying frameworks providing supporting technologies. Cocoa classes are reusable and extensible—you can use them as is or extend them for your particular requirements.</p><p>Cocoa makes it easy to create apps that adopt all of the conventions and expose all of the power of OS X. In fact, you can create a new Cocoa application project in Xcode and, without adding any code, have a functional app. Such an app is able to display its window (or create new documents) and implements many standard system behaviors. And although the Xcode templates provide some code to make this all happen, the amount of code they provide is minimal. Most of the behavior is provided by Cocoa itself.</p><p>To make a great app, you should build on the foundations Cocoa lays down for you, working with the conventions and infrastructure provided for you. To do so effectively, it's important to understand how a Cocoa app fits together.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW2" title="Fundamental Design Patterns"></a><h2 class="jump">Fundamental Design Patterns</h2><p>Cocoa incorporates many design patterns in its implementation. <span class="content_text">Table 2-1</span> lists the key design patterns with which you should be familiar.</p><a name="//apple_ref/doc/uid/TP40010543-CH3-SW4" title="Table 2-1Fundamental design patterns used by Mac apps"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 2-1</strong>&nbsp;&nbsp;Fundamental design patterns used by Mac apps</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Design pattern</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Why it is important</p></th></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Model-View-Controller" data-contents="The Model-View-Controller (MVC) design pattern assigns objects in an application one of three roles: model, view, or controller. "><a href="../../DevPedia-CocoaCore/MVC.html#//apple_ref/doc/uid/TP40008195-CH32" data-renderer-version="1" target="_self">Model-View-Controller</a></span></p></td><td ><p>Use of the <em class="newTerm">Model-View-Controller (MVC)</em> design pattern ensures that the objects you create now can be reused or updated easily in future versions of your app. </p><p>Cocoa provides most of the classes used to build your app’s controller and view layers. It is your job to customize the classes you need and provide the necessary data model objects to go with them. </p><p>MVC is central to a good design for a Cocoa application because many Cocoa technologies and architectures are based on MVC and require that your custom objects assume one of the MVC roles.</p></td></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Delegation" data-contents="Delegation is a simple and powerful pattern in which one object in a program acts on behalf of, or in coordination with, another object. "><a href="../../DevPedia-CocoaCore/Delegation.html#//apple_ref/doc/uid/TP40008195-CH14" data-renderer-version="1" target="_self">Delegation</a></span></p></td><td ><p>The <em class="newTerm">delegation</em> design pattern allows you to change the runtime behavior of an object without subclassing. Delegate objects conform to a specific <span class="pediaLink" data-header="Protocol" data-contents="A protocol declares a programmatic interface that any class may choose to implement. "><a href="../../DevPedia-CocoaCore/Protocol.html#//apple_ref/doc/uid/TP40008195-CH45" data-renderer-version="1" target="_self">protocol</a></span> that defines the interaction points between the delegate and the object it modifies. At specific points, the master object calls the methods of its delegate to provide it with information or ask what to do. The delegate can then take whatever actions are appropriate.</p></td></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Responder object" data-contents="A responder is an object that can respond to events and handle them. "><a href="../../Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1" data-renderer-version="1" target="_self">Responder chain</a></span></p></td><td ><p>The <em class="newTerm">responder chain</em> defines the relationships between event-handling objects in your app. As events arrive, the app dispatches them to the first responder object for handling. If that object does not want the event, it passes it to the next responder, which can either handle the event or send it to its next responder, and so on up the chain.</p><p>Windows and views are the most common types of responder objects and are always the first responders for mouse events. Other types of objects, such as your app’s controller objects, may also be responders.</p></td></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Target-Action" data-contents="Target-action is a design pattern in which an object holds the information necessary to send a message to another object when an event occurs. "><a href="../../Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3" data-renderer-version="1" target="_self">Target-action</a></span></p></td><td ><p>Controls use the <em class="newTerm">target-action</em> design pattern to notify your app of user interactions. When the user interacts with a control in a predefined way (such as by touching a button), the control sends a message (the action) to an object you specify (the target). Upon receiving the action message, the target object can then respond in an appropriate manner.</p></td></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Block object" data-contents="Block objects are a C-level syntactic and runtime feature that allow you to compose function expressions that can be passed as arguments, optionally stored, and used by multiple threads. "><a href="../../DevPedia-CocoaCore/Block.html#//apple_ref/doc/uid/TP40008195-CH3" data-renderer-version="1" target="_self">Block objects</a></span></p></td><td ><p><em class="newTerm">Block objects</em> are a convenient way to encapsulate code and local stack variables in a form that can be executed later. Blocks are used in lieu of callback functions by many frameworks and are also used in conjunction with Grand Central Dispatch to perform tasks asynchronously. </p><p>For more information about using blocks, see <em><a href="../../../../Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" data-renderer-version="1" target="_self">Blocks Programming Topics</a></em>. </p></td></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Notification" data-contents="A notification is a message sent to one or more observing objects to inform them of an event in a program. "><a href="../../DevPedia-CocoaCore/Notification.html#//apple_ref/doc/uid/TP40008195-CH35" data-renderer-version="1" target="_self">Notifications</a></span></p></td><td ><p><strong>Notifications</strong> are used throughout Cocoa to deliver news of changes to your app. Many objects send notifications at key moments in the object’s life cycle. Intercepting these notifications gives you a chance to respond and add custom behavior.</p></td></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Key-value observing" data-contents="Key-value observing is a mechanism that enables an object to be notified directly when a property of another object changes. "><a href="../../DevPedia-CocoaCore/KVO.html#//apple_ref/doc/uid/TP40008195-CH16" data-renderer-version="1" target="_self">Key-value observing (KVO)</a></span></p></td><td ><p><strong>KVO</strong> tracks changes to a specific property of an object. When that property changes, the change generates automatic notifications for any objects that registered an interest in that property. Those observers then have a chance to respond to the change. </p></td></tr><tr><td  scope="row"><p><span class="pediaLink" data-header="Dynamic binding" data-contents="Dynamic binding is determining the method to invoke at runtime instead of at compile time. "><a href="../../DevPedia-CocoaCore/DynamicBinding.html#//apple_ref/doc/uid/TP40008195-CH15" data-renderer-version="1" target="_self">Bindings</a></span></p></td><td ><p><strong>Cocoa bindings</strong> provide a convenient bridge between the model, view, and controller portions of your app. You bind a view to some underlying data object (which can be static or dynamic) through one of your controllers. Changes to the view are then automatically reflected in the data object, and vice versa. </p><p>The use of bindings is not required for apps but does minimize the amount of code you have to write. You can set up bindings programmatically or using Interface Builder.  </p></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW3" title="The App Style Determines the Core Architecture"></a><h2 class="jump">The App Style Determines the Core Architecture</h2><p>The style of your app defines which core objects you must use in its implementation. Cocoa supports the creation of both single-window and multiwindow apps. For multiwindow designs, it also provides a document architecture to help manage the files associated with each app window. Thus, apps can have the following forms: </p><ul class="ul"><li class="li"><p>Single-window utility app</p></li><li class="li"><p>Single-window library-style app</p></li><li class="li"><p>Multiwindow document-based app</p></li></ul><p>You should choose a basic app style early in your design process because that choice affects everything you do later. The single-window styles are preferred in many cases, especially for developers bringing apps from iOS. The single-window style typically yields a more streamlined user experience, and it also makes it easier for your app to support a full-screen mode. However, if your app works extensively with complex documents, the multiwindow style may be preferable because it provides more document-related infrastructure to help you implement your app.</p><p>The Calculator app provided with OS X, shown in <span class="content_text">Figure 2-1</span>, is an example of a single-window utility app. Utility apps typically handle ephemeral data or manage system processes. Calculator does not create or deal with any documents or persistent user data but simply processes numerical data entered by the user into the text field in its single window, displaying the results of its calculations in the same field. When the user quits the app, the data it processed is simply discarded.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW38" title="Figure 2-1The Calculator single-window utility app"></a><figcaption><strong class="caption_number">Figure 2-1</strong>&nbsp;&nbsp;The Calculator single-window utility app</figcaption><img src="../Art/calculator_2x.png" alt="" width="249" height="298"></figure><p>Single-window, library-style (or “shoebox”) apps do handle persistent user data. One of the most prominent examples of a library-style app is iPhoto, shown in <span class="content_text">Figure 2-2</span>. The user data handled by iPhoto are photos (and associated metadata), which the app edits, displays, and stores. All user interaction with iPhoto happens in a single window. Although iPhoto stores its data in files, it doesn’t present the files to the user. The app presents a simplified interface so that users don’t need to manage files in order to use the app. Instead, they work directly with their photos. Moreover, iPhoto hides its files from regular manipulation in the Finder by placing them within a single package. In addition, the app saves the user’s editing changes to disk at appropriate times. So, users are relieved of the need to manually save, open, or close documents. This simplicity for users is one of the key advantages of the library-style app design.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW44" title="Figure 2-2The iPhoto single-window app"></a><figcaption><strong class="caption_number">Figure 2-2</strong>&nbsp;&nbsp;The iPhoto single-window app</figcaption><img src="../Art/iphoto_2x.png" alt="" width="557" height="429"></figure><p>A good example of a multiwindow document-based app is TextEdit, which creates, displays, and edits documents containing plain or styled text and images. TextEdit does not organize or manage its documents—users do that with the Finder. Each TextEdit document opens in its own window, multiple documents can be open at one time, and the user interacts with the frontmost document using controls in the window’s toolbar and the app’s menu bar. <span class="content_text">Figure 2-3</span> shows a document created by TextEdit. For more information about the document-based app design, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW45" data-renderer-version="1">Document-Based Apps Are Based on an NSDocument Subclass</a></span>.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW43" title="Figure 2-3TextEdit document window"></a><figcaption><strong class="caption_number">Figure 2-3</strong>&nbsp;&nbsp;TextEdit document window</figcaption><img src="../Art/textedit_2x.png" alt="" width="509" height="448"></figure><p>Both single-window and multiwindow apps can present an effective full-screen mode, which provides an immersive experience that enables users to focus on their tasks without distractions. For information about full-screen mode, see <span class="content_text"><a href="../FullScreenApp/FullScreenApp.html#//apple_ref/doc/uid/TP40010543-CH6-SW1" data-renderer-version="1">Implementing the Full-Screen Experience</a></span>.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW23" title="The Core Objects for All Cocoa Apps"></a><h3 class="jump">The Core Objects for All Cocoa Apps</h3><p>Regardless of whether you are using a single-window or multiwindow app style, all apps use the same core set of objects. Cocoa provides the default behavior for most of these objects. You are expected to provide a certain amount of customization of these objects to implement your app’s custom behavior.  </p><p><span class="content_text">Figure 2-4</span> shows the relationships among the core objects for the single-window app styles. The objects in this figure are separated according to whether they are part of the <span class="pediaLink" data-header="Model-View-Controller" data-contents="The Model-View-Controller (MVC) design pattern assigns objects in an application one of three roles: model, view, or controller. "><a href="../../DevPedia-CocoaCore/MVC.html#//apple_ref/doc/uid/TP40008195-CH32" data-renderer-version="1" target="_self">model, view, or controller</a></span> portions of the app. As you can see from the figure, the Cocoa–provided objects provide much of the controller and view layer for your app. </p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW7" title="Figure 2-4Key objects in a single-window app"></a><figcaption><strong class="caption_number">Figure 2-4</strong>&nbsp;&nbsp;Key objects in a single-window app</figcaption><img src="../Art/single-window-app_2x.png" alt="" width="538" height="449"></figure><p><span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW8" data-renderer-version="1">Table 2-2</a></span> describes the roles played by the objects in the diagram. </p><a name="//apple_ref/doc/uid/TP40010543-CH3-SW8" title="Table 2-2The core objects used by all Cocoa apps"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 2-2</strong>&nbsp;&nbsp;The core objects used by all Cocoa apps</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Object</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p><code><a href="https://developer.apple.com/reference/appkit/nsapplication" target="_self" class="urlLink">NSApplication</a></code> object</p></td><td ><p>(Required) Runs the event loop and manage interactions between your app and the system. You typically use the <code>NSApplication</code> class as is, putting any custom app-object-related code in your application delegate object.</p></td></tr><tr><td  scope="row"><p>Application <span class="pediaLink" data-header="Delegation" data-contents="Delegation is a simple and powerful pattern in which one object in a program acts on behalf of, or in coordination with, another object. "><a href="../../DevPedia-CocoaCore/Delegation.html#//apple_ref/doc/uid/TP40008195-CH14" data-renderer-version="1" target="_self">delegate</a></span> object</p></td><td ><p>(Expected) A custom object that you provide which works closely with the <code>NSApplication</code> object to run the app and manage the transitions between different application states.</p><p>Your application delegate object must conform to the <code><a href="https://developer.apple.com/reference/appkit/nsapplicationdelegate" target="_self" class="urlLink">NSApplicationDelegate Protocol</a></code>. </p></td></tr><tr><td  scope="row"><p>Data model objects</p></td><td ><p>Store content specific to your app. A banking app might store a database containing financial transactions, whereas a painting app might store an image object or the sequence of drawing commands that led to the creation of that image.</p></td></tr><tr><td  scope="row"><p>Window controllers</p></td><td ><p>Responsible for loading and managing a single window each and coordinating with the system to handle standard window behaviors. </p><p>You subclass <code><a href="https://developer.apple.com/reference/appkit/nswindowcontroller" target="_self" class="urlLink">NSWindowController</a></code> to manage both the window and its contents. Each window controller is responsible for everything that happens in its window. If the contents of your window are simple, the window controller may do all of the management itself. If your window is more complex, the window controller might use one or more view controllers to manage portions of the window. </p></td></tr><tr><td  scope="row"><p>Window objects</p></td><td ><p>Represent your onscreen windows, configured in different styles depending on your app’s needs. For example, most windows have title bars and borders but you can also configure windows without those visual adornments. A window object is almost always managed by a window controller.</p><p>An app can also have secondary windows, also known as dialogs and panels. These windows are subordinate to the current document window or, in the case of single-window apps, to the main window. They support the document or main window, for example, allowing selection of fonts and color, allowing the selection of tools from a palette, or displaying a warning‚ A secondary window is often modal.</p></td></tr><tr><td  scope="row"><p>View controllers</p></td><td ><p>Coordinate the loading of a single view hierarchy into your app. Use view controllers to divide up the work for managing more sophisticated window layouts. Your view controllers work together (with the window controller) to present the window contents. </p><p>If you have developed iOS apps, be aware that AppKit view controllers play a less prominent role than UIKit view controllers. In OS X, AppKit view controllers are assistants to the window controller, which is ultimately responsible for everything that goes in the window. The main job of an AppKit view controller is to load its view hierarchy. Everything else is custom code that you write.</p></td></tr><tr><td  scope="row"><p>View objects</p></td><td ><p>Define a rectangular region in a window, draw the contents of that region, and handle events in that region. Views can be layered on top of each other to create view hierarchies, whereby one view obscures a portion of the underlying view.</p></td></tr><tr><td  scope="row"><p>Control objects</p></td><td ><p>Represent standard system controls. These view subclasses provide standard visual items such as buttons, text fields, and tables that you can use to build your user interface. Although a few controls are used as is to present visual adornments, most work with your code to manage user interactions with your app’s content.</p></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW6" title="Additional Core Objects for Multiwindow Apps"></a><h3 class="jump">Additional Core Objects for Multiwindow Apps</h3><p>As opposed to a single-window app, a multiwindow app uses several windows to present its primary content. The Cocoa support for multiwindow apps is built around a document-based model implemented by a subsystem called the <strong>document architecture</strong>. In this model, each document object manages its content, coordinates the reading and writing of that content from disk, and presents the content in a window for editing. All document objects work with the Cocoa infrastructure to coordinate event delivery and such, but each document object is otherwise independent of its fellow document objects.</p><p><span class="content_text">Figure 2-5</span> shows the relationships among the core objects of a multiwindow document-based app. Many of the same objects in this figure are identical to those used by a single-window app. The main difference is the insertion of the <code><a href="https://developer.apple.com/reference/appkit/nsdocumentcontroller" target="_self" class="urlLink">NSDocumentController</a></code> and <code><a href="https://developer.apple.com/reference/appkit/nsdocument" target="_self" class="urlLink">NSDocument</a></code> objects between the application objects and the objects for managing the user interface.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW5" title="Figure 2-5Key objects in a multiwindow document app"></a><figcaption><strong class="caption_number">Figure 2-5</strong>&nbsp;&nbsp;Key objects in a multiwindow document app</figcaption><img src="../Art/multi-window-app_2x.png" alt="" width="535" height="526"></figure><p><span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW9" data-renderer-version="1">Table 2-3</a></span> describes the role of the inserted <code><a href="https://developer.apple.com/reference/appkit/nsdocumentcontroller" target="_self" class="urlLink">NSDocumentController</a></code> and <code><a href="https://developer.apple.com/reference/appkit/nsdocument" target="_self" class="urlLink">NSDocument</a></code> objects. (For information about the roles of the other objects in the diagram, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW8" data-renderer-version="1">Table 2-2</a></span>.)</p><a name="//apple_ref/doc/uid/TP40010543-CH3-SW9" title="Table 2-3Additional objects used by multiwindow document apps"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 2-3</strong>&nbsp;&nbsp;Additional objects used by multiwindow document apps</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Object</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p>Document Controller object</p></td><td ><p>The <code>NSDocumentController</code> class defines a high-level controller for creating and managing all document objects. In addition to managing documents, the document controller also manages many document-related menu items, such as the Open Recent menu and the open and save panels. </p></td></tr><tr><td  scope="row"><p>Document object</p></td><td ><p>The <code><a href="https://developer.apple.com/reference/appkit/nsdocument" target="_self" class="urlLink">NSDocument</a></code> class is the base class for implementing documents in a multiwindow app. This class acts as the controller for the data objects associated with the document. You define your own custom subclasses to manage the interactions with your app’s data objects and to work with one or more <code><a href="https://developer.apple.com/reference/appkit/nswindowcontroller" target="_self" class="urlLink">NSWindowController</a></code> objects to display the document contents on the screen.</p></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW19" title="Integrating iCloud Support Into Your App"></a><h3 class="jump">Integrating iCloud Support Into Your App</h3><p>No matter how you store your app’s data, iCloud is a convenient way to make that data available to all of a user’s devices. To integrate iCloud into your app, you change where you store user files. Instead of storing them in the user’s Home folder or in your App Sandbox container, you store them in special file system locations known as <em>ubiquity containers</em>. A <em class="newTerm">ubiquity container</em> serves as the local representation of corresponding iCloud storage. It is outside of your App Sandbox container, and so requires specific entitlements for your app to interact with it.</p><p>In addition to a change in file system locations, your app design needs to acknowledge that your data model is accessible to multiple processes. The following considerations apply:</p><ul class="ul"><li class="li"><p>Document-based apps get iCloud support through the <code><a href="https://developer.apple.com/reference/appkit/nsdocument" target="_self" class="urlLink">NSDocument</a></code> class, which handles most of the interactions required to manage the on-disk file packages that represent documents.</p></li><li class="li"><p>If you implement a custom data model and manage files yourself, you must explicitly use file coordination to ensure that the changes you make are done safely and in concert with the changes made on the user’s other devices. For details, see <span class="content_text"><a href="../../../../FileManagement/Conceptual/FileSystemProgrammingGuide/FileCoordinators/FileCoordinators.html#//apple_ref/doc/uid/TP40010672-CH11" data-renderer-version="1" target="_self">The Role of File Coordinators and Presenters</a></span> in <em><a href="../../../../FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672" data-renderer-version="1" target="_self">File System Programming Guide</a></em>.</p></li><li class="li"><p>For storing small amounts of data in iCloud, you use key-value storage. Use key-value storage for such things as stocks or weather information, locations, bookmarks, a recent-documents list, settings and preferences, and simple game state. Every iCloud app should take advantage of key-value storage. To interact with key-value storage, you use the shared <code><a href="https://developer.apple.com/reference/foundation/nsubiquitouskeyvaluestore" target="_self" class="urlLink">NSUbiquitousKeyValueStore</a></code> object.</p></li></ul><p>To learn how to adopt iCloud in your app, read  <em><a href="../../iCloudDesignGuide/Chapters/Introduction.html#//apple_ref/doc/uid/TP40012094" data-renderer-version="1" target="_self">iCloud Design Guide</a></em>.</p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW42" title="Shoebox-Style Apps Should Not Use NSDocument"></a><h3 class="jump">Shoebox-Style Apps Should Not Use NSDocument</h3><p>When implementing a single-window, shoebox-style (sometimes referred to as a “library” style) app, it is sometimes better not to use <code>NSDocument</code> objects to manage your content. The <code>NSDocument</code> class was designed specifically for use in multiwindow document apps. Instead, use custom controller objects to manage your data. Those custom controllers would then work with a view controller or your app’s main window controller to coordinate the presentation of the data.</p><p>Although you normally use an <code>NSDocumentController</code> object only in multiwindow apps, you can subclass it and use it in a single-window app to coordinate the Open Recent and similar behaviors. When subclassing, though, you must override any methods related to the creation of <code>NSDocument</code> objects.</p></section></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW45" title="Document-Based Apps Are Based on an NSDocument Subclass"></a><h2 class="jump">Document-Based Apps Are Based on an NSDocument Subclass</h2><p>Documents are containers for user data that can be stored in files and iCloud. In a document-based design, the app enables users to create and manage documents containing their data. One app typically handles multiple documents, each in its own window, and often displays more than one document at a time. For example, a word processor provides commands to create new documents, it presents an editing environment in which the user enters text and embeds graphics into the document, it saves the document data to disk (and, optionally, iCloud), and it provides other document-related commands, such as printing and version management. In Cocoa, the document-based app design is enabled by the document architecture, which is part of of the AppKit framework.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW46" title="Documents in OS X"></a><h3 class="jump">Documents in OS X</h3><p>There are several ways to think of a document. Conceptually, a document is a container for a body of information that can be named and stored in a disk file and in iCloud. In this sense, the document is not the same as the file but is an object in memory that owns and manages the document data. To users, the document is their information—such as text and graphics formatted on a page. Programmatically, a document is an instance of a custom <code>NSDocument</code> subclass that knows how to represent internally persistent data that it can display in windows. This document object knows how to read document data from a file and create an object graph in memory for the document data model. It also knows how to handle the user’s editing commands to modify the data model and write the document data back out to disk. So, the document object mediates between different representations of document data, as shown in <span class="content_text">Figure 2-6</span>.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW50" title="Figure 2-6Document file, object, and data model"></a><figcaption><strong class="caption_number">Figure 2-6</strong>&nbsp;&nbsp;Document file, object, and data model</figcaption><img src="../Art/document_model_2_2x.png" alt="" width="449" height="239"></figure><p>Using iCloud, documents can be shared automatically among a user’s computers and iOS devices. Changes to the document data are synchronized without user intervention. For information about iCloud, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW19" data-renderer-version="1">Integrating iCloud Support Into Your App</a></span>.</p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW51" title="The Document Architecture Provides Many Capabilities for Free"></a><h3 class="jump">The Document Architecture Provides Many Capabilities for Free</h3><p>The document-based style of app is a design choice that you should consider when you design your app. If it makes sense for your users to create multiple discrete sets of data, each of which they can edit in a graphical environment and store in files or iCloud, then you certainly should plan to develop a document-based app.</p><p>The Cocoa document architecture provides a framework for document-based apps to do the following things:</p><ul class="ul"><li class="li"><p><strong>Create new documents.</strong> The first time the user chooses to save a new document, it presents a dialog enabling the user to name and save the document in a disk file in a user-chosen location.</p></li><li class="li"><p><strong>Open existing documents stored in files.</strong> A document-based app specifies the types of document it can read and write, as well as read-only and write-only types. It can represent the data of different types internally and display the data appropriately. It can also close documents.</p></li><li class="li"><p><strong>Automatically save documents.</strong> Document-based apps can adopt autosaving in place, and its documents are automatically saved at appropriate times so that the data the user sees on screen is effectively the same as that saved on disk. Saving is done safely, so that an interrupted save operation does not leave data inconsistent.</p></li><li class="li"><p><strong>Asynchronously read and write document data.</strong> Reading and writing are done asynchronously on a background thread, so that lengthy operations do not make the app’s user interface unresponsive. In addition, reads and writes are coordinated using <code>NSFilePresenter</code> protocol and <code>NSFileCoordinator</code> class to reduce version conflicts. Coordinated reads and writes reduce version conflicts both among different apps sharing document data in local storage and among different instances of an app on different devices sharing document data via iCloud.</p></li><li class="li"><p><strong>Manage multiple versions of documents.</strong> Autosave creates versions at regular intervals, and users can manually save a version whenever they wish. Users can browse versions and revert the document’s contents to a chosen version using a Time Machine–like interface. The version browser is also used to resolve version conflicts from simultaneous iCloud updates.</p></li><li class="li"><p><strong>Print documents.</strong> The print dialog and page setup dialog enable the user to choose various page layouts.</p></li><li class="li"><p><strong>Monitor and set the document’s edited status and validate menu items.</strong> To avoid automatic saving of inadvertent changes, old files are locked from editing until explicitly unlocked by the user.</p></li><li class="li"><p><strong>Track changes.</strong> The document manages its edited status and implements multilevel undo and redo.</p></li><li class="li"><p><strong>Handle app and window delegation.</strong> Notifications are sent and delegate methods called at significant lifecycle events, such as when the app terminates.</p></li></ul><p>See <em><a href="../../../../DataManagement/Conceptual/DocBasedAppProgrammingGuideForOSX/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011179" data-renderer-version="1" target="_self">Document-Based App Programming Guide for Mac</a></em> for more detailed information about how to implement a document-based app.</p></section></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW10" title="The App Life Cycle"></a><h2 class="jump">The App Life Cycle</h2><p>The app life cycle is the progress of an app from its launch through its termination. Apps can be launched by the user or the system. The user launches apps by double-clicking the app icon, using Launchpad, or opening a file whose type is currently associated with the app. In OS X v10.7 and later, the system launches apps at user login time when it needs to restore the user’s desktop to its previous state.</p><p>When an app is launched, the system creates a process and all of the normal system-related data structures for it. Inside the process, it creates a main thread and uses it to begin executing your app’s code. At that point, your app’s code takes over and your app is running.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW11" title="The main Function is the App Entry Point"></a><h3 class="jump">The main Function is the App Entry Point</h3><p>Like any C-based app, the main entry point for a Mac app at launch time is the <code>main</code> function. In a Mac app, the <code>main</code> function is used only minimally. Its main job is to give control to the AppKit framework. Any new project you create in Xcode comes with a default <code>main</code> function like the one shown in <span class="content_text">Listing 2-1</span>. You should normally not need to change the implementation of this function.</p><a name="//apple_ref/doc/uid/TP40010543-CH3-SW21" title="Listing 2-1The main function of a Mac app"></a><p class="codesample clear"><strong class="caption_number">Listing 2-1</strong>&nbsp;&nbsp;The <code>main</code> function of a Mac app</p><div class="codesample clear"><table><tr><td scope="row"><pre>#import &lt;Cocoa/Cocoa.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(int argc, char *argv[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return NSApplicationMain(argc,  (const char **) argv);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code><a href="https://developer.apple.com/reference/appkit/1428499-nsapplicationmain" target="_self" class="urlLink">NSApplicationMain</a></code> function initializes your app and prepares it to run. As part of the initialization process, this function does several things:</p><ul class="ul"><li class="li"><p>Creates an instance of the <code><a href="https://developer.apple.com/reference/appkit/nsapplication" target="_self" class="urlLink">NSApplication</a></code> class. You can access this object from anywhere in your app using the <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428360-shared" target="_self" class="urlLink">sharedApplication</a></code> class method. </p></li><li class="li"><p>Loads the nib file specified by the <code>NSMainNibFile</code> key in the <code>Info.plist</code> file and instantiates all of the objects in that file.  This is your app’s main nib file and should contain your application delegate and any other critical objects that must be loaded early in the launch cycle. Any objects that are not needed at launch time should be placed in separate nib files and loaded later.</p></li><li class="li"><p>Calls the <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428631-run" target="_self" class="urlLink">run</a></code> method of your application object to finish the launch cycle and begin processing events.</p></li></ul><p>By the time the <code>run</code> method is called, the main objects of your app are loaded into memory but the app is still not fully launched. The <code>run</code> method notifies the application delegate that the app is about to launch, shows the application menu bar, opens any files that were passed to the app, does some framework housekeeping, and starts the event processing loop. All of this work occurs on the app’s main thread with one exception. Files may be opened in secondary threads if the <code><a href="https://developer.apple.com/reference/appkit/nsdocument/1515216-canconcurrentlyreaddocumentsofty" target="_self" class="urlLink">canConcurrentlyReadDocumentsOfType:</a></code> <span class="pediaLink" data-header="Class method" data-contents="A class method is a method that operates on class objects rather than instances of the class. "><a href="../../DevPedia-CocoaCore/ClassMethod.html#//apple_ref/doc/uid/TP40008195-CH8" data-renderer-version="1" target="_self">class method</a></span> of the corresponding <code>NSDocument</code> object returns <code><!--a  -->YES<!--/a--></code>.</p><p>If your app preserves its user interface between launch cycles, Cocoa loads any preserved data at launch time and uses it to re-create the windows that were open the last time your app was running. For more information about how to preserve your app’s user interface, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW26" data-renderer-version="1">User Interface Preservation</a></span>.  </p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW13" title="The App’s Main Event Loop Drives Interactions"></a><h3 class="jump">The App’s Main Event Loop Drives Interactions</h3><p>As the user interacts with your app, the app’s main event loop processes incoming events and dispatches them to the appropriate objects for handling. When the <code><a href="https://developer.apple.com/reference/appkit/nsapplication" target="_self" class="urlLink">NSApplication</a></code> object is first created, it establishes a connection with the system window server, which receives events from the underlying hardware and transfers them to the app. The app also sets up a FIFO event queue to store the events sent to it by the window server. The main event loop is then responsible for dequeueing and processing events waiting in the queue, as shown in <span class="content_text">Figure 2-7</span>.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW12" title="Figure 2-7The main event loop"></a><figcaption><strong class="caption_number">Figure 2-7</strong>&nbsp;&nbsp;The main event loop</figcaption><img src="../Art/main_event_loop2_2x.png" alt="" width="510" height="233"></figure><p>The <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428631-run" target="_self" class="urlLink">run</a></code> method of the <code>NSApplication</code> object is the workhorse of the main event loop. In a closed loop, this method executes the following steps until the app terminates: </p><ol class="ol"><li class="li"><p>Services window-update notifications, which results in the redrawing of any windows that are marked as “dirty.”</p></li><li class="li"><p>Dequeues an event from its internal event queue using the <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428485-nextevent" target="_self" class="urlLink">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> method and converts the event data into an <code><a href="https://developer.apple.com/reference/appkit/nsevent" target="_self" class="urlLink">NSEvent</a></code> object. </p></li><li class="li"><p>Dispatches the event to the appropriate target object using the <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428359-sendevent" target="_self" class="urlLink">sendEvent:</a></code> method of <code>NSApplication</code>.</p></li></ol><p>When the app dispatches an event, the <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428359-sendevent" target="_self" class="urlLink">sendEvent:</a></code> method uses the type of the event to determine the appropriate target. There are two major types of input events: key events and mouse events. Key events are sent to the <em class="newTerm">key window</em>—the window that is currently accepting key presses. Mouse events are dispatched to the window in which the event occurred.</p><p>For mouse events, the window looks for the view in which the event occurred and dispatches the event to that object first. Views are <span class="pediaLink" data-header="Responder object" data-contents="A responder is an object that can respond to events and handle them. "><a href="../../Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1" data-renderer-version="1" target="_self">responder objects</a></span> and are capable of responding to any type of event. If the view is a control, it typically uses the event to generate an <span class="pediaLink" data-header="Target-Action" data-contents="Target-action is a design pattern in which an object holds the information necessary to send a message to another object when an event occurs. "><a href="../../Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3" data-renderer-version="1" target="_self">action message</a></span> for its associated target.</p><p>The overall process for handling events is described in detail in <em><a href="../../../../Cocoa/Conceptual/EventOverview/Introduction/Introduction.html#//apple_ref/doc/uid/10000060i" data-renderer-version="1" target="_self">Cocoa Event Handling Guide</a></em>.  </p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW22" title="Automatic and Sudden Termination of Apps Improve the User Experience"></a><h3 class="jump">Automatic and Sudden Termination of Apps Improve the User Experience</h3><p>In OS X v10.7 and later, the use of the Quit command to terminate an app is diminished in favor of more user-centric techniques. Specifically, Cocoa supports two techniques that make the termination of an app transparent and fast: </p><ul class="ul"><li class="li"><p><em class="newTerm">Automatic termination</em> eliminates the need for users to quit an app. Instead, the system manages app termination transparently behind the scenes, terminating apps that are not in use to reclaim needed resources such as memory. </p></li><li class="li"><p><em class="newTerm">Sudden termination</em> allows the system to kill an app’s process immediately without waiting for it to perform any final actions. The system uses this technique to improve the speed of operations such as logging out of, restarting, or shutting down the computer. </p></li></ul><p>Automatic termination and sudden termination are independent techniques, although both are designed to improve the user experience of app termination. Although Apple recommends that apps support both, an app can support one  technique and not the other. Apps that support both techniques can be terminated by the system without the app being involved at all. On the other hand, if an app supports sudden termination but not automatic termination, then it must be sent a Quit event, which it needs to process without displaying any user interface dialogs.</p><p>Automatic termination transfers the job of managing processes from the user to the system, which is better equipped to handle the job. Users do not need to manage processes manually anyway. All they really need is to run apps and have those apps available when they need them. Automatic termination makes that possible while ensuring that system performance is not adversely affected.</p><p>Apps must opt in to both automatic termination and sudden termination and implement appropriate support for them. In both cases, the app must ensure that any user data is saved well before termination can happen. And because the user does not quit an autoterminable app, such an app should also save the state of its user interface using the built-in Cocoa support. Saving and restoring the interface state provides the user with a sense of continuity between app launches.</p><p>For information on how to support for automatic termination in your app, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW27" data-renderer-version="1">Automatic Termination</a></span>. For information on how to support sudden termination, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW28" data-renderer-version="1">Sudden Termination</a></span>. </p></section></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW14" title="Support the Key Runtime Behaviors in Your Apps"></a><h2 class="jump">Support the Key Runtime Behaviors in Your Apps</h2><p>No matter what style of app you are creating, there are specific behaviors that all apps should support. These behaviors are intended to help users focus on the content they are creating rather than focus on app management and other busy work that is not part of creating their content.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW27" title="Automatic Termination"></a><h3 class="jump">Automatic Termination</h3><p>Automatic termination is a feature that you must explicitly code for in your app. Declaring support for automatic termination is easy, but apps also need to work with the system to save the current state of their user interface so that it can be restored later as needed. The system can kill the underlying process for an auto-terminable app at any time, so saving this information maintains continuity for the app. Usually, the system kills an app’s underlying process some time after the user has closed all of the app’s windows. However, the system may also kill an app with open windows if the app is not currently on screen, perhaps because the user hid it or switched spaces.</p><p>To support automatic termination, you should do the following:</p><ul class="ul"><li class="li"><p>Declare your app’s support for automatic termination, either programmatically or using an <code>Info.plist</code> key.</p></li><li class="li"><p>Support saving and restoring your window configurations. </p></li><li class="li"><p>Save the user’s data at appropriate times.</p><ul class="nested"><li class="nested li"><p>Single-window, library-style apps should implement strategies for saving data at appropriate checkpoints.</p></li><li class="nested li"><p>Multiwindow, document-based apps can use the autosaving and saveless documents capabilities in <code>NSDocument</code>.</p></li></ul></li><li class="li"><p>Whenever possible, support sudden termination for your app as well. </p></li></ul><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW29" title="Enabling Automatic Termination in Your App"></a><h4 class="jump">Enabling Automatic Termination in Your App</h4><p>Declaring support for automatic termination lets the system know that it should manage the actual termination of your app at appropriate times. An app has two ways to declare its support for automatic termination:</p><ul class="ul"><li class="li"><p>Include the <code>NSSupportsAutomaticTermination</code> key (with the value <code><!--a  -->YES<!--/a--></code>) in the app’s <code>Info.plist</code> file. This sets the app’s default support status.</p></li><li class="li"><p>Use the <code><a href="https://developer.apple.com/reference/foundation/nsprocessinfo" target="_self" class="urlLink">NSProcessInfo</a></code> class to declare support for automatic termination dynamically. Use this technique to change the default support of an app that includes the <code>NSSupportsAutomaticTermination</code> key in its <code>Info.plist</code> file.</p></li></ul></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW33" title="Automatic Data-Saving Strategies Relieve the User"></a><h4 class="jump">Automatic Data-Saving Strategies Relieve the User</h4><p>You should always avoid forcing the user to save changes to their data manually. Instead, implement automatic data saving. For a multiwindow app based on <code>NSDocument</code>, automatic saving is as simple as overriding the <code><a href="https://developer.apple.com/reference/appkit/nsdocument/1515106-autosavesinplace" target="_self" class="urlLink">autosavesInPlace</a></code> class method to return <code><!--a  -->YES<!--/a--></code>. For more information, see <em><a href="../../../../DataManagement/Conceptual/DocBasedAppProgrammingGuideForOSX/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011179" data-renderer-version="1" target="_self">Document-Based App Programming Guide for Mac</a></em>.</p><p>For a single-window, library-style app, identify appropriate points in your code where any user-related changes should be saved and write those changes to disk automatically. This benefits the user by eliminating the need to think about manually saving changes, and when done regularly, it ensures that the user does not lose much data if there is a problem.</p><p>Some appropriate times when you can save user data automatically include the following:</p><ul class="ul"><li class="li"><p>When the user closes the app window or quits the app (<code><a href="https://developer.apple.com/reference/appkit/nsapplicationdelegate/1428522-applicationwillterminate" target="_self" class="urlLink">applicationWillTerminate:</a></code>)</p></li><li class="li"><p>When the app is deactivated (<code><a href="https://developer.apple.com/reference/appkit/nsapplicationdelegate/1428539-applicationwillresignactive" target="_self" class="urlLink">applicationWillResignActive:</a></code>)</p></li><li class="li"><p>When the user hides your app (<code><a href="https://developer.apple.com/reference/appkit/nsapplicationdelegate/1428478-applicationwillhide" target="_self" class="urlLink">applicationWillHide:</a></code>)</p></li><li class="li"><p>Whenever the user makes a valid change to data in your app</p></li></ul><p>The last item means that you have the freedom to save the user’s data at any time it makes sense to do so. For example, if the user is editing fields of a data record, you can save each field value as it is changed or you can wait and save all fields when the user displays a new record. Making these types of incremental changes ensures that the data is always up-to-date but also requires more fine-grained management of your data model. In such an instance, Core Data can help you make the changes more easily. For information about Core Data, see <em><!--a target="_self" -->Core Data Starting Point<!--/a--></em>.</p></section></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW28" title="Sudden Termination"></a><h3 class="jump">Sudden Termination</h3><p>Sudden termination lets the system know that your app’s process can be killed directly without any additional involvement from your app. The benefit of supporting sudden termination is that it lets the system close apps more quickly, which is important when the user is shutting down a computer or logging out. </p><p>An app has two ways to declare its support for sudden termination: </p><ul class="ul"><li class="li"><p>Include the <code>NSSupportsSuddenTermination</code> key (with the value <code><!--a  -->YES<!--/a--></code>) in the app’s <code>Info.plist</code> file. </p></li><li class="li"><p>Use the <code><a href="https://developer.apple.com/reference/foundation/nsprocessinfo" target="_self" class="urlLink">NSProcessInfo</a></code> class to declare support for sudden termination dynamically. You can also use this class to change the default support of an app that includes the <code>NSSupportsSuddenTermination</code> key in its <code>Info.plist</code> file. </p></li></ul><p>One solution is to declare global support for the feature globally and then manually override the behavior at appropriate times. Because sudden termination means the system can kill your app at any time after launch, you should disable it while performing actions that might lead to data corruption if interrupted. When the action is complete, reenable the feature again. </p><p>You disable and enable sudden termination programmatically using the <code><a href="https://developer.apple.com/reference/foundation/processinfo/1412841-disablesuddentermination" target="_self" class="urlLink">disableSuddenTermination</a></code> and <code><a href="https://developer.apple.com/reference/foundation/processinfo/1409836-enablesuddentermination" target="_self" class="urlLink">enableSuddenTermination</a></code> methods of the <code>NSProcessInfo</code> class. These methods increment and decrement a counter, respectively, maintained by the process. When the value of this counter is 0, the process is eligible for sudden termination. When the value is greater than 0, sudden termination is disabled.</p><p>Enabling and disabling sudden termination dynamically also means that your app should save data progressively and not rely solely on user actions to save important information. The best way to ensure that your app’s information is saved at appropriate times is to support the interfaces in OS X v10.7 for saving your document and window state. Those interfaces facilitate the automatic saving of relevant user and app data. For more information about saving your user interface state, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW26" data-renderer-version="1">User Interface Preservation</a></span>. For more information about saving your documents, see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40010543-CH3-SW45" data-renderer-version="1">Document-Based Apps Are Based on an NSDocument Subclass</a></span>. </p><p>For additional information about enabling and disabling sudden termination, see <em><a href="https://developer.apple.com/reference/foundation/nsprocessinfo" target="_self" class="urlLink">NSProcessInfo Class Reference</a></em>. </p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW26" title="User Interface Preservation"></a><h3 class="jump">User Interface Preservation</h3><p>The Resume feature, in OS X v10.7 and later, saves the state of your app’s windows and restores them during subsequent launches of your app. Saving the state of your windows enables you to return your app to the state it was in when the user last used it. Use the Resume feature especially if your app supports automatic termination, which can cause your app to be terminated while it is running but hidden from the user. If your app supports automatic termination but does not preserve its interface, the app launches into its default state. Users who only switched away from your app might think that the app crashed while it was not being used.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW20" title="Writing Out the State of Your Windows and Custom Objects"></a><h4 class="jump">Writing Out the State of Your Windows and Custom Objects</h4><p>You must do the following to preserve the state of your user interface:</p><ul class="ul"><li class="li"><p>For each window, you must set whether the window should be preserved using the <code><a href="https://developer.apple.com/reference/appkit/nswindow/1526255-isrestorable" target="_self" class="urlLink">setRestorable:</a></code> method.</p></li><li class="li"><p>For each preserved window, you must specify an object whose job is to re-create that window at launch time.</p></li><li class="li"><p>Any objects involved in your user interface must write out the data they require to restore their state later.</p></li><li class="li"><p>At launch time, you must use the provided data to restore your objects to their previous state.</p></li></ul><p>The actual process of writing out your application state to disk and restoring it later is handled by Cocoa, but you must tell Cocoa what to save. Your app’s windows are the starting point for all save operations. Cocoa iterates over all of your app’s windows and saves data for the ones whose <code><a href="https://developer.apple.com/reference/appkit/nswindow/1526255-restorable" target="_self" class="urlLink">isRestorable</a></code> method returns <code><!--a  -->YES<!--/a--></code>. Most windows are preserved by default, but you can change the preservation state of a window using the <code><a href="https://developer.apple.com/reference/appkit/nswindow/1526255-isrestorable" target="_self" class="urlLink">setRestorable:</a></code> method.</p><p>In addition to preserving your windows, Cocoa saves data for most of the responder objects associated with the window. Specifically, it saves the views and window controller objects associated with the window. (For a multiwindow document-based app, the window controller also saves data from its associated document object.) <span class="content_text">Figure 2-8</span> shows the path that Cocoa takes when determining which objects to save. Window objects are always the starting point, but other related objects are saved, too.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW30" title="Figure 2-8Responder objects targeted by Cocoa for preservation"></a><figcaption><strong class="caption_number">Figure 2-8</strong>&nbsp;&nbsp;Responder objects targeted by Cocoa for preservation</figcaption><img src="../Art/saved_objects_2x.png" alt="" width="489" height="280"></figure><p>All Cocoa window and view objects save basic information about their size and location, plus information about other attributes that might affect the way they are currently displayed. For example, a tab view saves the index of the selected tab, and a text view saves the location and range of the current text selection. However, these responder objects do not have any inherent knowledge about your app’s data structures. Therefore, it is your responsibility to save your app’s data and any additional information needed to restore the window to its current state. There are several places where you can write out your custom state information:</p><ul class="ul"><li class="li"><p>If you subclass <code><a href="https://developer.apple.com/reference/appkit/nswindow" target="_self" class="urlLink">NSWindow</a></code> or <code><a href="https://developer.apple.com/reference/appkit/nsview" target="_self" class="urlLink">NSView</a></code>, implement the <code><a href="https://developer.apple.com/reference/appkit/nsresponder/1526236-encoderestorablestatewithcoder" target="_self" class="urlLink">encodeRestorableStateWithCoder:</a></code> method in your subclass and use it to write out any relevant data. </p><p>Alternatively, your custom <span class="pediaLink" data-header="Responder object" data-contents="A responder is an object that can respond to events and handle them. "><a href="../../Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1" data-renderer-version="1" target="_self">responder objects</a></span> can override the <code><a href="https://developer.apple.com/reference/appkit/nsresponder/1526242-restorablestatekeypaths" target="_self" class="urlLink">restorableStateKeyPaths</a></code> method and use it to specify key paths for any attributes to be preserved. Cocoa uses the key paths to locate and save the data for the corresponding attribute. Attributes must be compliant with <span class="pediaLink" data-header="Key-value coding" data-contents="Key-value coding is a mechanism for indirectly accessing an object’s attributes and relationships using string identifiers. "><a href="../../DevPedia-CocoaCore/KeyValueCoding.html#//apple_ref/doc/uid/TP40008195-CH25" data-renderer-version="1" target="_self">key-value coding</a></span> and <span class="pediaLink" data-header="Key-value observing" data-contents="Key-value observing is a mechanism that enables an object to be notified directly when a property of another object changes. "><a href="../../DevPedia-CocoaCore/KVO.html#//apple_ref/doc/uid/TP40008195-CH16" data-renderer-version="1" target="_self">Key-value observing</a></span>.</p></li><li class="li"><p>If your window has a delegate object, implement the <code><a href="https://developer.apple.com/reference/appkit/nswindowdelegate/1419619-window" target="_self" class="urlLink">window:willEncodeRestorableState:</a></code> method for the delegate and use it to store any relevant data.</p></li><li class="li"><p>In your window controller, use the <code>encodeRestorableStateWithCoder:</code> method to save any relevant data or configuration information.</p></li></ul><p>Be judicious when deciding what data to preserve, and strive to write out the smallest amount of information that is required to reconfigure your window and associated objects. You are expected to save the actual data that the window displays and enough information to reattach the window to the same data objects later.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/TP40010543-CH3-DontLinkElementID_9" title="Important"></a><p><strong>Important:</strong>&nbsp;Never use the user interface preservation mechanism as a way to save your app’s actual data. The archive created for interface preservation can change frequently and may be ignored altogether if there is a problem during the restoration process. Your app data should always be saved independently in data files that are managed by your app. </p><p></p></aside></div><p>For information on how to use coder objects to archive state information, see <em><a href="https://developer.apple.com/reference/foundation/nscoder" target="_self" class="urlLink">NSCoder Class Reference</a></em>. For additional information on what you need to do to save state in a multiwindow document-based app, see <em><a href="../../../../DataManagement/Conceptual/DocBasedAppProgrammingGuideForOSX/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011179" data-renderer-version="1" target="_self">Document-Based App Programming Guide for Mac</a></em>.</p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW34" title="Notifying Cocoa About Changes to Your Interface State"></a><h4 class="jump">Notifying Cocoa About Changes to Your Interface State</h4><p>Whenever the preserved state of one of your <span class="pediaLink" data-header="Responder object" data-contents="A responder is an object that can respond to events and handle them. "><a href="../../Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1" data-renderer-version="1" target="_self">responder objects</a></span> changes, mark the object as dirty by calling the <code><a href="https://developer.apple.com/reference/appkit/nsresponder/1526243-invalidaterestorablestate" target="_self" class="urlLink">invalidateRestorableState</a></code> method of that object. Having done so, at some point in the future, <code><a href="https://developer.apple.com/reference/appkit/nsresponder/1526236-encoderestorablestatewithcoder" target="_self" class="urlLink">encodeRestorableStateWithCoder:</a></code> message is sent to your responder object. Marking your responder objects as dirty lets Cocoa know that it needs to write their preservation state to disk at an appropriate time. Invalidating your objects is a lightweight operation in itself because the data is not written to disk right away. Instead, changes are coalesced and written at key times, such as when the user switches to another app or logs out.</p><p>You should mark a responder object as dirty only for changes that are truly interface related. For example, a tab view marks itself as dirty when the user selects a different tab. However, you do not need to invalidate your window or its views for many content-related changes, unless the content changes themselves caused the window to be associated with a completely different set of data-providing objects.</p><p>If you used the <code><a href="https://developer.apple.com/reference/appkit/nsresponder/1526242-restorablestatekeypaths" target="_self" class="urlLink">restorableStateKeyPaths</a></code> method to declare the attributes you want to preserve, Cocoa preserves and restores the values of those attributes of your responder object. Therefore, any key paths you provide should be <span class="pediaLink" data-header="Key-value observing" data-contents="Key-value observing is a mechanism that enables an object to be notified directly when a property of another object changes. "><a href="../../DevPedia-CocoaCore/KVO.html#//apple_ref/doc/uid/TP40008195-CH16" data-renderer-version="1" target="_self">key-value observing</a></span> compliant and generate the appropriate notifications. For more information on how to support key-value observing in your objects, see <em><a href="../../../../Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i" data-renderer-version="1" target="_self">Key-Value Observing Programming Guide</a></em>.</p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW35" title="Restoring Your Windows and Custom Objects at Launch TIme"></a><h4 class="jump">Restoring Your Windows and Custom Objects at Launch TIme</h4><p>As part of your app’s normal launch cycle, Cocoa checks to see whether there is any preserved interface data. If there is, Cocoa uses that data to try to re-create your app’s windows. Every window must identify a <em class="newTerm">restoration class</em> that knows about the window and can act on its behalf at launch time to create the window when asked to do so by Cocoa.</p><p>The restoration class is responsible for creating both the window and all of the critical objects required by that window. For most app styles, the restoration class usually creates one or more controller objects as well. For example, in a single-window app, the restoration class would likely create the window controller used to manage the window and then retrieve the window from that object. Because it creates these controller objects too, you typically use high-level application classes for your restoration classes. An app might use the application delegate, a document controller, or even a window controller as a restoration class.</p><p>During the launch cycle, Cocoa restores each preserved window as follows:</p><ol class="ol"><li class="li"><p>Cocoa retrieves the window’s restoration class from the preserved data and calls its <code><a href="https://developer.apple.com/reference/appkit/nswindowrestoration/1526251-restorewindowwithidentifier" target="_self" class="urlLink">restoreWindowWithIdentifier:state:completionHandler:</a></code> <span class="pediaLink" data-header="Class method" data-contents="A class method is a method that operates on class objects rather than instances of the class. "><a href="../../DevPedia-CocoaCore/ClassMethod.html#//apple_ref/doc/uid/TP40008195-CH8" data-renderer-version="1" target="_self">class method</a></span>. </p></li><li class="li"><p>The <code>restoreWindowWithIdentifier:state:completionHandler:</code> class method must call the provided completion handler with the desired window object. To do this, it does one of the following:</p><ul class="ul"><li class="li"><p>It creates any relevant controller objects (including the window controller) that might normally be created to display the window.</p></li><li class="li"><p>If the controller objects already exist (perhaps because they were already loaded from a nib file), the method gets the window from those existing objects. </p></li></ul><p>If the window could not be created, perhaps because the associated document was deleted by the user, the <code>restoreWindowWithIdentifier:state:completionHandler:</code> should pass an error object to the completion handler.</p></li><li class="li"><p>Cocoa uses the returned window to restore it and any preserved responder objects to their previous state. </p><ul class="ul"><li class="li"><p>Standard Cocoa window and view objects are restored to their previous state without additional help. If you subclass <code><a href="https://developer.apple.com/reference/appkit/nswindow" target="_self" class="urlLink">NSWindow</a></code> or <code><a href="https://developer.apple.com/reference/appkit/nsview" target="_self" class="urlLink">NSView</a></code>, implement the <code><a href="https://developer.apple.com/reference/appkit/nsresponder/1526253-restorestate" target="_self" class="urlLink">restoreStateWithCoder:</a></code> method to restore any custom state. </p><p>If you implemented the <code><a href="https://developer.apple.com/reference/appkit/nsresponder/1526242-restorablestatekeypaths" target="_self" class="urlLink">restorableStateKeyPaths</a></code> method in your custom <span class="pediaLink" data-header="Responder object" data-contents="A responder is an object that can respond to events and handle them. "><a href="../../Devpedia-CocoaApp/Responder.html#//apple_ref/doc/uid/TP40009071-CH1" data-renderer-version="1" target="_self">responder objects</a></span>, Cocoa automatically sets the value of the associated attributes to their preserved values. Thus, you do not have to implement the <code>restoreStateWithCoder:</code> to restore these attributes.</p></li><li class="li"><p>For the window delegate object, Cocoa calls the <code><a href="https://developer.apple.com/reference/appkit/nswindowdelegate/1419475-window" target="_self" class="urlLink">window:didDecodeRestorableState:</a></code> method to restore the state of that object.</p></li><li class="li"><p>For your window controller, Cocoa calls the <code>restoreStateWithCoder:</code> method to restore its state.</p></li></ul></li></ol><p>When re-creating each window, Cocoa passes the window’s unique identifier string to the restoration class. You are responsible for assigning user interface identifier strings to your windows prior to preserving the window state. You can assign an identifier in your window’s nib file or by setting your window object's <code><a href="https://developer.apple.com/reference/appkit/nsuserinterfaceitemidentification/1396829-identifier" target="_self" class="urlLink">identifier</a></code> property (defined in <code><a href="https://developer.apple.com/reference/appkit/nsuserinterfaceitemidentification" target="_self" class="urlLink">NSUserInterfaceItemIdentification</a></code> protocol). For example, you might give your preferences window an identifier of <code>preferences</code> and then check for that identifier in your implementation. Your restoration class can use this identifier to determine which window and associated objects it needs to re-create. The contents of an identifier string can be anything you want but should be something to help you identify the window later.</p><p>For a single-window app whose main window controller and window are loaded from the main nib file, the job of your restoration class is fairly straightforward. Here, you could use the application delegate’s class as the restoration class and implement the <code>restoreWindowWithIdentifier:state:completionHandler:</code> method similar to the implementation shown in <span class="content_text">Listing 2-2</span>. Because the app has only one window, it returns the main window directly. If you used the application delegate’s class as the restoration class for other windows, your own implementation could use the identifier parameter to determine which window to create. </p><a name="//apple_ref/doc/uid/TP40010543-CH3-SW31" title="Listing 2-2Returning the main window for a single-window app"></a><p class="codesample clear"><strong class="caption_number">Listing 2-2</strong>&nbsp;&nbsp;Returning the main window for a single-window app</p><div class="codesample clear"><table><tr><td scope="row"><pre>+ (void)restoreWindowWithIdentifier:(NSString *)identifier<span></span></pre></td></tr><tr><td scope="row"><pre>        state:(NSCoder *)state<span></span></pre></td></tr><tr><td scope="row"><pre>        completionHandler:(void (^)(NSWindow *, NSError *))completionHandler<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   // Get the window from the window controller,<span></span></pre></td></tr><tr><td scope="row"><pre>   // which is stored as an outlet by the delegate.<span></span></pre></td></tr><tr><td scope="row"><pre>   // Both the app delegate and window controller are<span></span></pre></td></tr><tr><td scope="row"><pre>   // created when the main nib file is loaded.<span></span></pre></td></tr><tr><td scope="row"><pre>   MyAppDelegate* appDelegate = (MyAppDelegate*)[[NSApplication sharedApplication] delegate];<span></span></pre></td></tr><tr><td scope="row"><pre>   NSWindow* mainWindow = [appDelegate.windowController window];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>   // Pass the window to the provided completion handler.<span></span></pre></td></tr><tr><td scope="row"><pre>   completionHandler(mainWindow, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section></section></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW15" title="Apps Are Built Using Many Different Pieces"></a><h2 class="jump">Apps Are Built Using Many Different Pieces</h2><p>The objects of the core architecture are important but are not the only objects you need to consider in your design. The core objects manage the high-level behavior of your app, but the objects in your app’s view layer do most of the work to display your custom content and respond to events. Other objects also play important roles in creating interesting and engaging apps.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW16" title="The User Interface"></a><h3 class="jump">The User Interface</h3><p>An app’s user interface is made up of a menu bar, one or more windows, and one or more views. The <em class="newTerm">menu bar</em> is a repository for commands that the user can perform in the app. Commands may apply to the app as a whole, to the currently active window, or to the currently selected object. You are responsible for defining the commands that your app supports and for providing the event-handling code to respond to them.</p><p>You use windows and views to present your app’s visual content on the screen and to manage the immediate interactions with that content. A <em class="newTerm">window</em> is an instance of the <code><a href="https://developer.apple.com/reference/appkit/nswindow" target="_self" class="urlLink">NSWindow</a></code> class. A <em class="newTerm">panel</em> is an instance of the <code><a href="https://developer.apple.com/reference/appkit/nspanel" target="_self" class="urlLink">NSPanel</a></code> class (which is a descendant of <code>NSWindow</code>) that you use to present secondary content. Single-window apps have one main window and may have one or more secondary windows or panels. Multiwindow apps have multiple windows for displaying their primary content and may have one or more secondary windows or panels too. The style of a window determines its appearance on the screen. <span class="content_text">Figure 2-9</span> shows the menu bar, along with some standard windows and panels.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW24" title="Figure 2-9Windows and menus in an app"></a><figcaption><strong class="caption_number">Figure 2-9</strong>&nbsp;&nbsp;Windows and menus in an app</figcaption><img src="../Art/window_layer_image_2x.png" class="wide-image" alt="" width="803" height="340"><img src="../Art/window_layer_image_2x.png" class="ipad-scaled-image" alt="" width="670" height="283"></figure><p>A <em class="newTerm">view</em>, an instance of the <code><a href="https://developer.apple.com/reference/appkit/nsview" target="_self" class="urlLink">NSView</a></code> class, defines the content for a rectangular region of a window. Views are the primary mechanism for presenting content and interacting with the user and have several responsibilities. For example:</p><ul class="ul"><li class="li"><p><strong>Drawing and animation support.</strong> Views draw content in their rectangular area. Views that support Core Animation layers can use those layers to animate their contents.</p></li><li class="li"><p><strong>Layout and subview management.</strong> Each view manages a list of subviews, allowing you to create arbitrary view hierarchies. Each view defines layout and resizing behaviors to accommodate changes in the window size.</p></li><li class="li"><p><strong>Event handling.</strong> Views receive events. Views forward events to other objects when appropriate.</p></li></ul><p>For information about creating and configuring windows, see <em><a href="../../../../Cocoa/Conceptual/WinPanel/Introduction.html#//apple_ref/doc/uid/10000031i" data-renderer-version="1" target="_self">Window Programming Guide</a></em>. For information about using and creating view hierarchies, see <em><a href="../../../../Cocoa/Conceptual/CocoaViewsGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978" data-renderer-version="1" target="_self">View Programming Guide</a></em>.</p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW17" title="Event Handling"></a><h3 class="jump">Event Handling</h3><p>The system window server is responsible for tracking mouse, keyboard, and other events and delivering them to your app. When the system launches an app, it creates both a process and a single thread for the app. This initial thread becomes the app’s main thread. In it, the <code><a href="https://developer.apple.com/reference/appkit/nsapplication" target="_self" class="urlLink">NSApplication</a></code> object sets up the <em class="newTerm">main run loop</em> and configures its event-handling code, as shown in <span class="content_text">Figure 2-10</span>. As the window server delivers events, the app queues those events and then processes them sequentially in the app’s main run loop. Processing an event involves dispatching the event to the object best suited to handle it. For example, mouse events are usually dispatched to the view in which the event occurred.  </p><figure class="figure"><a name="//apple_ref/doc/uid/TP40010543-CH3-SW39" title="Figure 2-10Processing events in the main run loop"></a><figcaption><strong class="caption_number">Figure 2-10</strong>&nbsp;&nbsp;Processing events in the main run loop</figcaption><img src="../Art/main_event_loop_2x.png" class="wide-image" alt="Processing events in the main run loop" width="711" height="241"><img src="../Art/main_event_loop_2x.png" class="ipad-scaled-image" alt="Processing events in the main run loop" width="670" height="227"></figure><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40010543-CH3-SW40" title="Note"></a><p><strong>Note:</strong>&nbsp;A run loop monitors sources of input on a specific thread of execution. The app’s event queue represents one of these input sources. While the event queue is empty, the main thread sleeps. When an event arrives, the run loop wakes up the thread and dispatches control to the <code>NSApplication</code> object to handle the event. After the event has been handled, control passes back to the run loop, which can then process another event, process other input sources, or put the thread back to sleep if there is nothing more to do. For more information about how run loops and input sources work, see <em><a href="../../../../Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i" data-renderer-version="1" target="_self">Threading Programming Guide</a></em>.</p><p></p></aside></div><p>Distributing and handling events is the job of responder objects, which are instances of the <code><a href="https://developer.apple.com/reference/appkit/nsresponder" target="_self" class="urlLink">NSResponder</a></code> class. The <code>NSApplication</code>, <code><a href="https://developer.apple.com/reference/appkit/nswindow" target="_self" class="urlLink">NSWindow</a></code>, <code><a href="https://developer.apple.com/reference/appkit/nsdrawer" target="_self" class="urlLink">NSDrawer</a></code>, <code><a href="https://developer.apple.com/reference/appkit/nsview" target="_self" class="urlLink">NSView</a></code>, <code><a href="https://developer.apple.com/reference/appkit/nswindowcontroller" target="_self" class="urlLink">NSWindowController</a></code>, and <code><a href="https://developer.apple.com/reference/appkit/nsviewcontroller" target="_self" class="urlLink">NSViewController</a></code> classes are all descendants of <code>NSResponder</code>. After pulling an event from the event queue, the app dispatches that event to the window object where it occurred. The window object, in turn, forwards the event to its <em class="newTerm">first responder</em>. In the case of mouse events, the first responder is typically the view object (<code>NSView</code>) in which the touch took place. For example, a mouse event occurring in a button is delivered to the corresponding button object.</p><p>If the first responder is unable to handle an event, it forwards the event to its <em class="newTerm">next responder</em>, which is typically a parent view, view controller, or window. If that object is unable to handle the event, it forwards it to its next responder, and so on, until the event is handled. This series of linked responder objects is known as the <em class="newTerm">responder chain</em>. Messages continue traveling up the responder chain—toward higher-level responder objects, such as a window controller or the application object—until the event is handled. If the event isn't handled, it is discarded.</p><p>The responder object that handles an event often sets in motion a series of programmatic actions by the app. For example, a control object (that is, a subclass of <code><a href="https://developer.apple.com/reference/appkit/nscontrol" target="_self" class="urlLink">NSControl</a></code>) handles an event by sending an action message to another object, typically the controller that manages the current set of active views. While processing the action message, the controller might change the user interface or adjust the position of views in ways that require some of those views to redraw themselves. When this happens, the view and graphics infrastructure takes over and processes the required redraw events in the most efficient manner possible. </p><p>For more information about responders, the responder chain, and handling events, see <em><a href="../../../../Cocoa/Conceptual/EventOverview/Introduction/Introduction.html#//apple_ref/doc/uid/10000060i" data-renderer-version="1" target="_self">Cocoa Event Handling Guide</a></em>.</p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW18" title="Graphics, Drawing, and Printing"></a><h3 class="jump">Graphics, Drawing, and Printing</h3><p>There are two basic ways in which a Mac app can draw its content: </p><ul class="ul"><li class="li"><p>Native drawing technologies (such as Core Graphics and AppKit)</p></li><li class="li"><p>OpenGL</p></li></ul><p>The native OS X drawing technologies typically use the infrastructure provided by Cocoa views and windows to render and present custom content. When a view is first shown, the system asks it to draw its content. System views draw their contents automatically, but custom views must implement a <code><a href="https://developer.apple.com/reference/appkit/nsview/1483686-draw" target="_self" class="urlLink">drawRect:</a></code> method. Inside this method, you use the native drawing technologies to draw shapes, text, images, gradients, or any other visual content you want. When you want to update your view’s visual content, you mark all or part of the view invalid by calling its <code><a href="https://developer.apple.com/reference/appkit/nsview/1483360-needsdisplay" target="_self" class="urlLink">setNeedsDisplay:</a></code> or <code><a href="https://developer.apple.com/reference/appkit/nsview/1483475-setneedsdisplay" target="_self" class="urlLink">setNeedsDisplayInRect:</a></code> method. The system then calls your view’s <code>drawRect:</code> method (at an appropriate time) to accommodate the update. This cycle then repeats and continues throughout the lifetime of your app.</p><p>If you are using OpenGL to draw your app’s content, you still create a window and view to manage your content, but those objects simply provide the rendering surface for an OpenGL drawing context. Once you have that drawing context, your app is responsible for initiating drawing updates at appropriate intervals.</p><p>For information about how to draw custom content in your views, see <em><a href="../../../../Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290" data-renderer-version="1" target="_self">Cocoa Drawing Guide</a></em>. </p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW47" title="Text Handling"></a><h3 class="jump">Text Handling</h3><p>The Cocoa text system, the primary text-handling system in OS X, is responsible for the processing and display of all visible text in Cocoa. It provides a complete set of high-quality typographical services through the text-related AppKit classes, which enable apps to create, edit, display, and store text with all the characteristics of fine typesetting.</p><p>The Cocoa text system provides all these basic and advanced text-handling features, and it also satisfies additional requirements from the ever-more-interconnected computing world: support for the character sets of all of the world’s living languages, powerful layout capabilities to handle various text directionality and nonrectangular text containers, and sophisticated typesetting capabilities such as control of kerning, ligatures, line breaking, and justification. Cocoa’s object-oriented text system is designed to provide all these capabilities without requiring you to learn about or interact with more of the system than is necessary to meet the needs of your app.</p><p>Underlying the Cocoa text system is Core Text, which provides low-level, basic text layout and font-handling capabilities to higher-level engines such as Cocoa and WebKit. Core Text provides the implementation for many Cocoa text technologies. App developers typically have no need to use Core Text directly. However, the Core Text API is accessible to developers who must use it directly, such as those writing apps with their own layout engine and those porting older ATSUI- or QuickDraw-based codebases to the modern world.</p><p>For more information about the Cocoa text system, see <em><a href="../../../../TextFonts/Conceptual/CocoaTextArchitecture/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009459" data-renderer-version="1" target="_self">Cocoa Text Architecture Guide</a></em>.</p></section></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW41" title="Implementing the Application Menu Bar"></a><h2 class="jump">Implementing the Application Menu Bar</h2><p></p><p>The classes <code>NSMenu</code> and <code>NSMenuItem</code> are the basis for all types of menus. An instance of <code>NSMenu</code> manages a collection of menu items and draws them one beneath another. An instance of <code>NSMenuItem</code> represents a menu item; it encapsulates all the information its <code>NSMenu</code> object needs to draw and manage it, but does no drawing or event-handling itself. You typically use Interface Builder to create and modify any type of menu, so often there is no need to write any code.</p><p>The application menu bar stretches across the top of the screen, replacing the menu bar of any other app when the app is foremost. All of an app’s menus in the menu bar are owned by one <code>NSMenu</code> instance that’s created by the app when it starts up.</p><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW48" title="Xcode Templates Provide the Menu Bar"></a><h3 class="jump">Xcode Templates Provide the Menu Bar</h3><p>Xcode’s Cocoa application templates provide that <code>NSMenu</code> instance in a nib file called <code>MainMenu.xib</code>. This nib file contains an application menu (named with the app’s name), a File menu (with all of its associated commands), an Edit menu (with text editing commands and Undo and Redo menu items), and Format, View, Window, and Help menus (with their own menu items representing commands). These menu items, as well as all of the menu items of the File menu, are connected to the appropriate first-responder action methods. For example, the About menu item is connected to the <code><a href="https://developer.apple.com/reference/appkit/nsapplication/1428724-orderfrontstandardaboutpanel" target="_self" class="urlLink">orderFrontStandardAboutPanel:</a></code> action method in the File’s Owner that displays a standard About window.</p><p>The template has similar ready-made connections for the Edit, Format, View, Window, and Help menus. If your app does not support any of the supplied actions (for example, printing), you should remove the associated menu items (or menu) from the nib. Alternatively, you may want to repurpose and rename menu commands and action methods to suit your own app, taking advantage of the menu mechanism in the template to ensure that everything is in the right place.</p></section><section><a name="//apple_ref/doc/uid/TP40010543-CH3-SW49" title="Connect Menu Items to Your Code or Your First Responder"></a><h3 class="jump">Connect Menu Items to Your Code or Your First Responder</h3><p>For your app’s custom menu items that are not already connected to action methods in objects or placeholder objects in the nib file, there are two common techniques for handling menu commands in a Mac app:</p><ul class="ul"><li class="li"><p>Connect the corresponding menu item to a first responder method.</p></li><li class="li"><p>Connect the menu item to a method of your custom application object or your application delegate object.</p></li></ul><p>Of these two techniques, the first is more common given that many menu commands act on the current document or its contents, which are part of the responder chain. The second technique is used primarily to handle commands that are global to the app, such as displaying preferences or creating a new document. It is possible for a custom application object or its delegate to dispatch events to documents, but doing so is generally more cumbersome and prone to errors. In addition to implementing action methods to respond to your menu commands, you must also implement the methods of the <code>NSMenuValidation</code> protocol to enable the menu items for those commands.</p><p>Step-by-step instructions for connecting menu items to action methods in your code are given in <span class="content_text"><!--a target="_self" -->Designing User Interfaces in Xcode<!--/a--></span>. For more information about menu validation and other menu topics, see <em><a href="../../../../Cocoa/Conceptual/MenuList/MenuList.html#//apple_ref/doc/uid/10000032i" data-renderer-version="1" target="_self">Application Menu and Pop-up List Programming Topics</a></em>.</p></section></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='../FullScreenApp/FullScreenApp.html'>Next</a><a class='previousLink' rel='prev' href='../AppRuntime/AppRuntime.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2015 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2015-03-09</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1260/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/feedback.js"></script>
</body>
</html>
