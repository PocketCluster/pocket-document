<!DOCTYPE html>
<html lang="en">
<head>
    <title>Dynamic Library Usage Guidelines</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40001869">
    <meta id="document-version" name="document-version" content="1.10.0">
    <meta id="build" name="build" content="ded95564c405529dbbbe590063edd114" />
    <meta id="chapterId" name="chapterId" content="TP40001928">
    <meta id="date" name="date" content="2012-07-23">
    <meta id="description" name="description" content="Explains how to design, implement, and use dynamic libraries.">
    <meta id="book-title" name="book-title" content="Dynamic Library Programming Topics">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="Mac Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/mac">
    <meta id="reflib" name="reflib" content="Guides and Sample Code">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/General}">
    
    
    <meta id="copyright" name="copyright" content="Copyright 2017 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Dynamic Library Programming Topics: Dynamic Library Usage Guidelines">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1260">
    <link id="book-index-page" rel="Start" title="Dynamic Library Programming Topics" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="CreatingDynamicLibraries.html">
    <link id="previous-page" rel="Prev" type="text/html" href="DynamicLibraryDesignGuidelines.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/feedback.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta id="platforms" name="platforms" content="">
</head>    
<body><a name="//apple_ref/doc/uid/TP40001928" title="Dynamic Library Usage Guidelines"></a>
    <div id="_omniture_top">
    <!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
    <script type="text/javascript">
    /* RSID: */
    var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
    </script>

    <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
    <script type="text/javascript">
    s.pageName=AC.Tracking.pageName();
    s.channel="www.us.developer"

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)</script>
    <!-- End SiteCatalyst code version: H.8. -->
    </div>

    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode unified">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>Guides and Sample Code</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search Guides and Sample Code</label>
            
            
    
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Dynamic Library Programming Topics</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='CreatingDynamicLibraries.html'>Next</a><a class='previousLink' rel='prev' href='DynamicLibraryDesignGuidelines.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/TP40001928-SW10" title="Dynamic Library Usage Guidelines"></a><h1 id="pageTitle">Dynamic Library Usage Guidelines</h1><p>The dynamic loader compatibility functions provide a portable and efficient way to load code at runtime. However, using the functions incorrectly can degrade app performance. This article shows how to correctly load and use dynamic libraries in your apps.</p><p>Dynamic libraries help to distribute an app’s functionality into distinct modules that can be loaded as they are needed. Dynamic libraries can be loaded either when the app launches or as it runs. Libraries that are loaded at launch time are called <em class="newTerm">dependent libraries</em>. Libraries that are loaded at runtime are called <em class="newTerm">dynamically loaded libraries</em>. You specify which dynamic libraries your app depends on by linking your app with them. However, it’s more efficient to use dynamic libraries as dynamically loaded libraries instead of dependent libraries. That is, you should open libraries when you’re about to use symbols they export and close them when you’re done. In some cases, the system unloads dynamically loaded libraries when it determines that they aren’t being used. </p><p>This article uses the word <em class="newTerm">image</em> to refer to an app file or a dynamic library. App binaries contain the app’s code and the code from the static libraries the app uses. The dynamic libraries the app loads at launch time or runtime are separate images.</p><section><a name="//apple_ref/doc/uid/TP40001928-SW12" title="Opening Dynamic Libraries"></a><h2 class="jump">Opening Dynamic Libraries</h2><p>The dynamic loader loads an image’s dependent libraries when the image is opened; that is, when an app is loaded or when a dynamic library is opened. The dynamic loader binds references to symbols exported by dependent libraries lazily. Lazy binding means that the symbol references are bound only when the image actually uses the symbols. As a debugging measure, you can specify that all references to the exported symbols of a library be bound when the dynamic loader opens the library. You use the compiler <code>-bind_at_load</code> command-line option when generating the dynamic library.</p><p>To use a dynamic library that is not a dependent library of your image, use the <code><!--a target="_self" -->dlopen(3) OS X Developer Tools  Manual Page<!--/a--></code> function. This function tells the dynamic loader to load a specific dynamic library into the address space of the current process. This function also allows you to specify when the  dynamic loader binds the library’s references to the corresponding exported symbols in its dependent libraries and whether to place the library’s exported symbols in the current process’s global scope or a local scope. This function returns a handle called <em class="newTerm">library handle</em>. This handle represents the dynamically loaded library in calls to <code>dlsym</code> (to use an exported symbol) and <code>dlclose</code> (to close the library). The library handle provides <code>dlsym</code> a limited domain within which to search for a symbol (see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40001928-SW9" data-renderer-version="1">Using Symbols</a></span> for details). The client must call <code>dlclose</code> when it’s finished using the dynamically loaded library (for example, when the module that opened the library has finished its task).</p><p>A dynamic library may itself have dependent libraries. To find out which libraries a dynamic library depends on, use the <code>otool -L &lt;library></code> command. Before using the library, you must ensure that all its dependent libraries are present in your computer. Otherwise, the dynamic loader doesn’t load your app or library when requested at launch time or when the library is opened with <code>dlopen</code>.</p><p>A process can open the same dynamic library several times without closing it. The <code>dlopen</code> function returns the same library handle it returned in the first call, but it also increments the reference count associated with the handle. Calls to <code>dlclose</code> decrement the library handle’s reference count. Therefore, you must balance every call to <code>dlopen</code> with a call to <code>dlclose</code>. When the reference count for a library handle reaches 0, the dynamic loader may remove the library from the address space of the app. </p><section><a name="//apple_ref/doc/uid/TP40001928-SW21" title="The Library Search Process"></a><h3 class="jump">The Library Search Process</h3><p>The first parameter to <code><!--a target="_self" -->dlopen(3) OS X Developer Tools  Manual Page<!--/a--></code> is the name of the dynamic library to open. This may be a filename or a partially or fully qualified pathname. For example, <code>libCelsus.dylib</code> , <code>lib/libCelsus.dylib</code> , or <code>/usr/local/libCelsus.dylib</code>.</p><p>The dynamic loader searches for libraries in the directories specified by a set of environment variables and the process’s current working directory. These variables, when defined, must contain a colon-separated list of pathnames (absolute or relative) in which the dynamic loader searches for libraries. <span class="content_text">Table 1</span> lists the variables.</p><a name="//apple_ref/doc/uid/TP40001928-SW1" title="Table 1Environment variables that define dynamic-loader search paths"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 1</strong>&nbsp;&nbsp;Environment variables that define dynamic-loader search paths</caption><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Environment variable</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Default value</p></th></tr><tr><td  scope="row"><p><code>LD_LIBRARY_PATH</code></p></td><td ><p>No default value</p></td></tr><tr><td  scope="row"><p><code>DYLD_LIBRARY_PATH</code></p></td><td ><p>No default value</p></td></tr><tr><td  scope="row"><p><code>DYLD_FALLBACK_LIBRARY_PATH</code></p></td><td ><p><code>$HOME/lib;/usr/local/lib;/usr/lib</code></p></td></tr></table></div><p>When the library name is a filename (that is, when it doesn’t include directory names), the dynamic loader searches for the library in several locations until it finds it, in the following order:</p><ol class="ol"><li class="li"><p><code>$LD_LIBRARY_PATH</code></p></li><li class="li"><p><code>$DYLD_LIBRARY_PATH</code></p></li><li class="li"><p>The process’s working directory</p></li><li class="li"><p><code>$DYLD_FALLBACK_LIBRARY_PATH</code></p></li></ol><p>When the library name contains at least one directory name, that is, when the name is a pathname (relative or fully qualified), the dynamic loader searches for the library in the following order:</p><ol class="ol"><li class="li"><p><code>$DYLD_LIBRARY_PATH</code> using the filename</p></li><li class="li"><p>The given pathname</p></li><li class="li"><p><code>$DYLD_FALLBACK_LIBRARY_PATH</code> using the filename</p></li></ol><p>For example, say you set the environment variables introduced earlier as shown in the following table.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Environment variable</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Value</p></th></tr><tr><td  scope="row"><p><code>LD_LIBRARY_PATH</code></p></td><td ><p><code>./lib</code></p></td></tr><tr><td  scope="row"><p><code>DYLD_LIBRARY_PATH</code></p></td><td ><p><code>/usr/local/dylibs</code></p></td></tr><tr><td  scope="row"><p><code>DYLD_FALLBACK_LIBRARY_PATH</code></p></td><td ><p><code>/usr/local/lib</code></p></td></tr></table></div><p>Assuming your  app calls <code>dlopen</code> with the filename <code>libCelsus.dylib</code>, the dynamic loader would attempt to open the library using the following pathnames, in order:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Pathname</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p><code>./lib/libCelsus.dylib</code></p></td><td ><p><code>LD_LIBRARY_PATH</code> environment variable</p></td></tr><tr><td  scope="row"><p><code>/usr/local/dylibs/libCelsus.dylib</code></p></td><td ><p><code>DYLD_LIBRARY_PATH</code> environment variable</p></td></tr><tr><td  scope="row"><p><code>libCelsus.dylib</code></p></td><td ><p>Current working directory</p></td></tr><tr><td  scope="row"><p><code>/usr/local/lib/libCelsus.dylib</code></p></td><td ><p><code>DYLD_FALLBACK_LIBRARY_PATH</code> environment variable</p></td></tr></table></div><p>If the app calls <code>dlopen</code> with the pathname <code>/libs/libCelsus.dylib</code>, the dynamic loader tries to find the library using these pathnames, in order:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Pathname</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td  scope="row"><p><code>/usr/local/dylibs/libCelsus.dylib</code></p></td><td ><p><code>DYLD_LIBRARY_PATH</code> environment variable</p></td></tr><tr><td  scope="row"><p><code>/libs/libCelsus.dylib</code></p></td><td ><p>Path as given</p></td></tr><tr><td  scope="row"><p><code>/usr/local/lib/libCelsus.dylib</code></p></td><td ><p><code>DYLD_FALLBACK_LIBRARY_PATH</code> environment variable</p></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40001928-SW22" title="Specifying the Scope and Binding Behavior of Exported Symbols"></a><h3 class="jump">Specifying the Scope and Binding Behavior of Exported Symbols</h3><p>The second parameter of the <code><!--a target="_self" -->dlopen(3) OS X Developer Tools  Manual Page<!--/a--></code> function specifies two properties: the scope of the library's exported symbols in the current process and when to bind the app’s references the those symbols.</p><p>Symbol scope directly affects the performance of apps. Therefore, it’s important that you set the appropriate scope for a library your app opens at runtime.</p><p>A dynamically loaded library’s exported symbols can be in one of two levels of scope in the current process: global and local. The main difference between the scopes is that the symbols in the global scope are available to all images in the process, including other dynamically loaded libraries. Symbols in the local scope can be used only by the image that opened the library. See <span class="content_text"><a href="#//apple_ref/doc/uid/TP40001928-SW9" data-renderer-version="1">Using Symbols</a></span> for more information.</p><p>When the dynamic loader searches for symbols, it performs string comparisons with every symbol in the search scope. Reducing the number of symbols the dynamic loader has to go through to find the desired symbol improves your app’s performance. Opening all dynamically loaded libraries into the local scope instead of the global scope maximizes symbol search performance.</p><p>You should never need to open a dynamic library into the process’s global scope so that all modules in the app have access to its symbols. Instead, each module that uses the library should open it into its local scope. When done, the module should close the library. If you want the symbols exported by the library to be available to all images in the process, consider making the library a dependent library of the app.</p><p>The parameter used to specify symbol scope is also used to specify when the undefined external symbols of the dynamically loaded library are resolved (or bound with their definitions in the library’s own dependent libraries). Undefined external symbols of dynamically loaded libraries can be resolved either immediately or lazily. If a client app uses immediate binding when opening a dynamic library with <code>dlopen</code> , the dynamic loader binds all the undefined external symbols of the dynamically loaded library before returning control to the client app. For example, <span class="content_text">Listing 1</span> shows the log messages the dynamic loader produces when the <code>DYLD_PRINT_BINDINGS</code> environment variable is set and a client app loads a dynamic library called <code>libPerson.dylib</code> :</p><a name="//apple_ref/doc/uid/TP40001928-SW2" title="Listing 1Bindings resolved during call to dlopen using immediate binding"></a><p class="codesample clear"><strong class="caption_number">Listing 1</strong>&nbsp;&nbsp;Bindings resolved during call to <code>dlopen</code> using immediate binding</p><div class="codesample clear"><table><tr><td scope="row"><pre>dyld: lazy bind: client:0x107575050 = libdyld.dylib:_dlopen, *0x107575050 = 0x7FFF88740922<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9000 = libdyld.dylib:dyld_stub_binder, *0x1075A9000 = 0x7FFF887406A0<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9220 = libobjc.A.dylib:__objc_empty_cache, *0x1075A9220 = 0x7FFF7890EC10<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9248 = libobjc.A.dylib:__objc_empty_cache, *0x1075A9248 = 0x7FFF7890EC10<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9228 = libobjc.A.dylib:__objc_empty_vtable, *0x1075A9228 = 0x7FFF7890CF60<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9250 = libobjc.A.dylib:__objc_empty_vtable, *0x1075A9250 = 0x7FFF7890CF60<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9218 = CoreFoundation:_OBJC_CLASS_$_NSObject, *0x1075A9218 = 0x7FFF77C40BA8<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9238 = CoreFoundation:_OBJC_METACLASS_$_NSObject, *0x1075A9238 = 0x7FFF77C40B80<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9240 = CoreFoundation:_OBJC_METACLASS_$_NSObject, *0x1075A9240 = 0x7FFF77C40B80<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9260 = CoreFoundation:___CFConstantStringClassReference, *0x1075A9260 = 0x7FFF77C72760<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libPerson.dylib:0x1075A9280 = CoreFoundation:___CFConstantStringClassReference, *0x1075A9280 = 0x7FFF77C72760<span></span></pre></td></tr></table></div>	<p>The first log message indicates that the client app’s <code>_dlopen</code> undefined symbol was bound. The remaining messages are the bindings the dynamic loader performs on the dynamic library as part of the loading process before returning control to the calling routine. When using lazy binding, the dynamic loader resolves only the client’s reference to the <code>dlopen</code> function, returning control to the calling routine much sooner. For more information on dynamic loader logging, see <span class="content_text"><a href="LoggingDynamicLoaderEvents.html#//apple_ref/doc/uid/TP40002077-SW1" data-renderer-version="1">Logging Dynamic Loader Events</a></span>.</p><p>Once a library has been opened with <code>dlopen</code>, the scope defined for it cannot be changed by subsequent calls to <code>dlopen</code> to load the same library. For example, if the process opens a library that hasn’t been loaded into the local scope  and later opens the same library into the global scope, the opened library retains its local status. That is, the symbols the library exports do not become available in the global scope with the latter call. This is true even if the library is closed before reopening it within the same process. </p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/TP40001928-DontLinkElementID_5" title="Important"></a><p><strong>Important:</strong>&nbsp;All runtime loaded dynamic libraries should be opened into the local scope. Adhering to this rule makes finding symbols at runtime as fast as possible.</p><p></p></aside></div><p>Immediate binding slows the loading of dynamic libraries, especially when those libraries contain many undefined external symbols. However, immediate binding can help during development and testing of dynamic libraries because when the dynamic loader cannot resolve all the undefined external symbols of a dynamically loaded library, the app terminates with an error. When deploying the app, however, you should use lazy loading because undefined external symbols are bound only when necessary. Loading dynamic libraries this way can help make your app feel more responsive to its users.</p><p>The external undefined symbols in dependent libraries are bound when they are first used unless the client image’s compile line includes the <code>-bind_at_load</code> option. See the <code><!--a target="_self" -->ld<!--/a--></code> man page for details.</p></section></section><section><a name="//apple_ref/doc/uid/TP40001928-SW9" title="Using Symbols"></a><h2 class="jump">Using Symbols</h2><p>After opening a dynamic library using <code><!--a target="_self" -->dlopen(3) OS X Developer Tools  Manual Page<!--/a--></code>, an image uses the <code><!--a target="_self" -->dlsym(3) OS X Developer Tools  Manual Page<!--/a--></code> function to get the address of the desired symbol before using it. This  function takes two parameters. The first one specifies in which libraries the dynamic loader looks for the symbol. The second parameter specifies the name of the symbol. For example:</p><div class="codesample clear"><table><tr><td scope="row"><pre>symbol_pointer = dlsym(library_handle, "my_symbol")<span></span></pre></td></tr></table></div><p>This invocation tells the dynamic loader to search for a symbol named <code>my_symbol</code> among the symbols exported by the dynamically loaded library represented by the <code>library_handle</code> variable.</p><p>There are three scopes the dynamic loader can search for a symbol: a specific dynamic library, the current image's dependent libraries, and the global scope of the process:</p><ul class="ul"><li class="li"><p><strong>The local scope:</strong> To search the symbols exported by a particular dynamic library that has been loaded using <code>dlopen</code>, you provide <code>dlsym</code> with the handle to that library. This is the most efficient usage model.</p></li><li class="li"><p><strong>The next scope:</strong> This search scope is useful only when a module has interposed a symbol exported by a dependent library. For example, you may need to intercept all calls to a system function to perform bookkeeping before calling the real implementation. In that case, in your custom definition of the function, you get the address of the function you interposed by invoking <code>dlsym</code> with the <code>RTLD_NEXT</code> special handle instead of the handle to a particular library. Such a call returns the address of the function that would have been executed if you hadn’t masked out that implementation with your own. Therefore, only the dependent libraries of the current image are searched; any other libraries, including libraries opened by the image making the <code>dlsym</code> call, are not searched. Also, in a flat namespace, the search starts in the first dependent library listed after the current one when the app was linked.</p></li><li class="li"><p><strong>The global scope:</strong> To search the global scope, you call <code>dlsym</code> with the  <code>RTLD_DEFAULT</code> special handle. The dynamic loader searches the dependent libraries (loaded at launch time) and the dynamically loaded libraries (loaded at runtime with <code>RTLD_GLOBAL</code> ) for the first match of the symbol name given to <code>dlsym</code> . You should avoid performing global symbol searches because they are the most inefficient.</p></li></ul><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40001928-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;Name conflicts between dynamic shared libraries are not discovered at compile time, link time, or runtime. The <code>dlsym</code> function uses string matching to find symbols. If two libraries use the same name for a function, the dynamic loader returns the first one that matches the symbol name given to <code>dlsym</code>.</p><p></p></aside></div><p>To illustrate the concepts introduced in this section, take the app depicted in <span class="content_text">Figure 1</span>. It shows that the app has two dependent libraries, <code>libArt.dylib</code> and <code>libBus.dylib</code>. The <code>libBus.dylib</code> library itself has two dependent libraries, <code>libBus1.dylib</code> and <code>libBus2.dylib</code>. The <code>libBus1.dylib</code> library has one dependent library, <code>libBus1a.dylib</code>. In addition, there are four dynamic libraries the app doesn’t depend on, <code>libCar.dylib</code>, <code>libCar1.dylib</code>, <code>libDot.dylib</code>, and <code>libDot1.dylib</code>. The <code>libCar1.dylib</code> library is a dependent library of <code>libCar.dylib</code> and <code>libDot1.dylib</code> is a dependent library of <code>libDot.dylib</code>. All the libraries except <code>libArt.dylib</code> export the <code>dependencies</code> function. Each library has a unique implementation of the <code>...name</code> function.</p><figure class="figure"><a name="//apple_ref/doc/uid/TP40001928-SW3" title="Figure 1App with dependent library hierarchy"></a><figcaption><strong class="caption_number">Figure 1</strong>&nbsp;&nbsp;App with dependent library hierarchy</figcaption><img src="../art/dylibhierarchy_2x.png" alt="" width="549" height="477"></figure><p>The app image can access the exported symbols in <code>libArt.dylib</code> and <code>libBus.dylib</code> directly, as shown in <span class="content_text">Listing 2</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW4" title="Listing 2App image using symbols exported by dependent libraries through undefined external references"></a><p class="codesample clear"><strong class="caption_number">Listing 2</strong>&nbsp;&nbsp;App image using symbols exported by dependent libraries through undefined external references</p><div class="codesample clear"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>extern char* A_name();          // libArt.dylib<span></span></pre></td></tr><tr><td scope="row"><pre>extern char* dependencies();    // libBus.dylib<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] libArt.A_name() = %s\n", __FILE__, A_name());<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] libBus.dependencies() = %s\n", __FILE__, dependencies());<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The app image, however, cannot directly access the symbols exported by <code>libBus1.dylib</code>, <code>libBus1a.dylib</code>, and <code>libBus2.dylib</code> because those libraries are not dependent libraries of the app image. To gain access to those symbols, the app image has to open the corresponding libraries using <code>dlopen</code>, as shown in <span class="content_text">Listing 3</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW5" title="Listing 3App image using a symbol exported by a dynamic library loaded at runtime"></a><p class="codesample clear"><strong class="caption_number">Listing 3</strong>&nbsp;&nbsp;App image using a symbol exported by a dynamic library loaded at runtime</p><div class="codesample clear"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    void* Bus1a_handle = dlopen("libBus1a.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (Bus1a_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>        char* (*b1a_name)() = dlsym(Bus1a_handle, "B1a_name");<span></span></pre></td></tr><tr><td scope="row"><pre>        if (b1a_name) {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("[%s] libBus1a.B1a_name() = %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                __FILE__, b1a_name());<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s] Unable to open libBus1a.dylib: %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            __FILE__, dlerror());<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    dlclose(Bus1a_handle);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>So far you have seen how to access symbols either through references to imported symbols or by obtaining the address of the desired symbol by calling <code>dlsym</code> with the handle of the corresponding library or with the <code>RTLD_DEFAULT</code> special handle. As mentioned earlier, interposed symbols offer the ability to change the definition of a symbol exported by a dependent library.</p><p>To access the original definition of interposed symbols, you call <code>dlsym</code> with the <code>RTLD_NEXT</code> special handle. <span class="content_text">Listing 4</span> shows the implementation of the <code>dependencies</code> function in the Bus library (the implementation is identical in Bus1 and Bus1a). The function in Bus returns the name of the library (contained in the <code>k_lib_name</code> variable) concatenated with a separator string and the text returned by the next definition of <code>dependencies</code>, which is found in the Bus1 library. The definition in Bus1 concatenates its name with a separator string and the text returned by the definition in Bus1a. The definition in Bus1a is the last that would’ve been found if none of the client images had defined their own version. Therefore, when Bus1a invokes <code>dlsym(RTLD_NEXT, "dependencies")</code> no other definitions for <code>dependencies</code> are found. That’s the end of the interposition hierarchy of the <code>dependencies</code> function.</p><a name="//apple_ref/doc/uid/TP40001928-SW6" title="Listing 4Library image using an interposed symbol"></a><p class="codesample clear"><strong class="caption_number">Listing 4</strong>&nbsp;&nbsp;Library image using an interposed symbol</p><div class="codesample clear"><table><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre>static char* k_lib_name = "libBus";<span></span></pre></td></tr><tr><td scope="row"><pre>char* dependencies(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    char _dependencies[50] = "";<span></span></pre></td></tr><tr><td scope="row"><pre>    strcpy(_dependencies, k_lib_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    char* (*next_dependencies)() =<span></span></pre></td></tr><tr><td scope="row"><pre>        dlsym(RTLD_NEXT, "dependencies");// look for next definition<span></span></pre></td></tr><tr><td scope="row"><pre>    if (next_dependencies) {<span></span></pre></td></tr><tr><td scope="row"><pre>        strncat(_dependencies, ", ",<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(_dependencies) - strlen(_dependencies) - 1);<span></span></pre></td></tr><tr><td scope="row"><pre>        strncat(_dependencies, next_dependencies(),<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(_dependencies) - strlen(_dependencies) - 1);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return strdup(_dependencies);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the image calls the dependencies function in the Bus library, it obtains the names of all the libraries the Bus library depends on, as shown in <span class="content_text">Listing 5</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW7" title="Listing 5App image calling an interposed function"></a><p class="codesample clear"><strong class="caption_number">Listing 5</strong>&nbsp;&nbsp;App image calling an interposed function</p><div class="codesample clear"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>extern char* dependencies();    // libBus.dylib<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] libBus.dependencies() = %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>        __FILE__, dependencies());<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40001928-SW13" title="Using Weakly Linked Symbols"></a><h2 class="jump"><a name="//apple_ref/doc/uid/TP40001928-SW20" title="Using Weakly Linked Symbols"></a>Using Weakly Linked Symbols</h2><p>To promote compatibility with earlier or later revisions, a dynamic library may export some or all its public symbols as weakly linked symbols. A <em class="newTerm">weakly linked symbol</em> is one for which the compiler generates a weak reference when a client is linked with a library. Weakly linked symbols may have the <code>weak_import</code> attribute in their declarations in the library’s header files, or the library’s developer may otherwise document which of the library’s public symbols are weakly linked. A third way to identify weakly linked symbols it by executing the command:</p><div class="codesample clear"><table><tr><td scope="row"><pre>nm -m &lt;client_file> | grep weak<span></span></pre></td></tr></table></div><p>This command lists the weakly linked symbols imported from dependent libraries.</p><p>A weakly linked symbol may or may not be defined by a dependent library. That is, although the symbol is declared in a header file, the corresponding dynamic library file may not contain an implementation of that symbol. <span class="content_text">Listing 6</span> shows how a weakly linked symbol may be declared in a header file for a dynamic library. Clients that use this header file as their interface to the corresponding dependent library are guaranteed that <code>name</code> and <code>set_name</code> are defined. However, <code>clear_name</code> may not be implemented. The dependent library loads successfully whether or not it implements <code>clear_name</code>. But it doesn’t load if it doesn’t define either <code>name</code> or <code>set_name</code>. When the library doesn’t implement a weakly linked symbol, the dynamic loader sets to 0 any client references to the symbol.</p><a name="//apple_ref/doc/uid/TP40001928-SW14" title="Listing 6Header file with a weakly linked symbol declaration"></a><p class="codesample clear"><strong class="caption_number">Listing 6</strong>&nbsp;&nbsp;Header file with a weakly linked symbol declaration</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#define WEAK_IMPORT __attribute__((weak_import))<span></span></pre></td></tr><tr><td scope="row"><pre>char* name(void);<span></span></pre></td></tr><tr><td scope="row"><pre>void set_name(char* name);<span></span></pre></td></tr><tr><td scope="row"><pre>WEAK_IMPORT<span></span></pre></td></tr><tr><td scope="row"><pre>void clear_name(void);<span></span></pre></td></tr></table></div><p>Weakly linked symbols are used by library developers to maximize the compatibility of a client with earlier or newer versions of a dependent library. For example, a symbol that was implemented in a particular revision of a library may not be available in a later revision. But a client linked with the first revision also works with the second revision. Client developers, however, must ensure the existence of the symbol in the running process before executing it. This mechanism is also used to provide a standard interface to plug-ins, which may or may not implement the entire interface.</p><p><span class="content_text">Listing 7</span> shows code that ensures that a particular function is defined before using it. When the function is not found, the client uses a different function to accomplish the desired task. In this case, the fallback function is not a weakly linked symbol, so no test is required. Other situations may not offer an alternate interface. In such cases the client may not be able to perform the desired task.</p><a name="//apple_ref/doc/uid/TP40001928-SW15" title="Listing 7Using a weakly linked symbol"></a><p class="codesample clear"><strong class="caption_number">Listing 7</strong>&nbsp;&nbsp;Using a weakly linked symbol</p><div class="codesample clear"><table><tr><td scope="row"><pre>// Clear the 'name' property.<span></span></pre></td></tr><tr><td scope="row"><pre>if (clear_name) {<span></span></pre></td></tr><tr><td scope="row"><pre>    clear_name();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>else {<span></span></pre></td></tr><tr><td scope="row"><pre>    set_name(" ");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40001928-SW11" title="Using C++ Classes"></a><h2 class="jump">Using C++ Classes</h2><p>How client developers use a C++ class depends on whether the dynamic library that implements it is loaded when the client is loaded (dependent library) or at a later point (runtime loaded library). Dependent-library classes can be used directly. That is, clients can create and delete objects with the <code>new</code> and <code>delete</code> operators. Classes implemented in libraries loaded at runtime with <code><!--a target="_self" -->dlopen(3) OS X Developer Tools  Manual Page<!--/a--></code> are called <em class="newTerm">runtime loaded classes</em>.</p><p>A runtime loaded class must be instantiated by the client using that class’s factory functions, declared as part of the class’s interface. <em class="newTerm">Factory functions</em> create and destroy instances of a specific class: Constructor functions instantiate objects and destructor functions destroy them. Clients must use factory functions instead of <code>new</code> and <code>delete</code> because the dynamic loader doesn’t have access to a runtime loaded class’s constructors and destructors. When the client calls a factory function, the library invokes the appropriate constructor and destructor on the client’s behalf. After you create an instance of a runtime loaded class, you invoke its member functions the same way you would call them if the class were defined locally.</p><p>The interface for C++ classes implemented in dynamic libraries is made up of at least the class declaration and a set of factory functions. The class interface includes one type definition per constructor function. To use a factory function, you must create an object of the appropriate type and get the address of the function with <code><!--a target="_self" -->dlsym(3) OS X Developer Tools  Manual Page<!--/a--></code>. You can then call the factory function to create or destroy an object of the class.</p><p><span class="content_text">Listing 8</span> shows the interface to the <code>Person</code> class, implemented in the Person library.</p><a name="//apple_ref/doc/uid/TP40001928-SW16" title="Listing 8C++ class interface"></a><p class="codesample clear"><strong class="caption_number">Listing 8</strong>&nbsp;&nbsp;C++ class interface</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>class Person {<span></span></pre></td></tr><tr><td scope="row"><pre>    private:<span></span></pre></td></tr><tr><td scope="row"><pre>        char _person_name[30];<span></span></pre></td></tr><tr><td scope="row"><pre>    public:<span></span></pre></td></tr><tr><td scope="row"><pre>        Person();<span></span></pre></td></tr><tr><td scope="row"><pre>        Person(char* name);<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual void set_name(char person_name[]);<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual char* name();<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Constructor functions and function types.<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" Person* NewPerson(void);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef Person * Person_creator(void);<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" Person* NewPersonWithName(char name[]);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef Person * PersonWithName_creator(char name[]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Destructor function and function type.<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" void DeletePerson(Person* person);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef void Person_disposer(Person*);<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 9</span> shows a possible implementation of the <code>Person</code> class.</p><a name="//apple_ref/doc/uid/TP40001928-SW27" title="Listing 9Implementation of the Person class in the Person library"></a><p class="codesample clear"><strong class="caption_number">Listing 9</strong>&nbsp;&nbsp;Implementation of the <code>Person</code> class in the Person library</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Person.cpp */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;iostream><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define EXPORT __attribute__((visibility("default")))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>Person::Person() {<span></span></pre></td></tr><tr><td scope="row"><pre>    char default_name[] = "&lt;no value>";<span></span></pre></td></tr><tr><td scope="row"><pre>    this->set_name(default_name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>Person::Person(char *name) {<span></span></pre></td></tr><tr><td scope="row"><pre>    this->set_name(name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>Person* NewPerson(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return new Person;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>Person* NewPersonWithName(char name[]) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return new Person(name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>void DeletePerson(Person* person) {<span></span></pre></td></tr><tr><td scope="row"><pre>    delete person;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void Person::set_name(char name[]) {<span></span></pre></td></tr><tr><td scope="row"><pre>    strcpy(_person_name, name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>char* Person::name(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that the <code>Person</code> class has two constructor functions, <code>NewPerson</code> and <code>NewPersonWithName</code>. Each function declaration has a corresponding type, <code>Person_creator</code> and <code>PersonWithName_creator</code>. <span class="content_text">Listing 10</span> and <span class="content_text">Listing 11</span> show how a client may use the Person library.</p><a name="//apple_ref/doc/uid/TP40001928-SW28" title="Listing 10Client using a C++ dependent library"></a><p class="codesample clear"><strong class="caption_number">Listing 10</strong>&nbsp;&nbsp;Client using a C++ dependent library</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Client.cpp */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;iostream><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cout;<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cerr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person* person1 = new Person();<span></span></pre></td></tr><tr><td scope="row"><pre>    char person_name[] = "Cendrine";<span></span></pre></td></tr><tr><td scope="row"><pre>    Person* person2 = new Person(person_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person1->name() = " &lt;&lt; person1->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person2->name() = " &lt;&lt; person2->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    char person1_name[] = "Floriane";<span></span></pre></td></tr><tr><td scope="row"><pre>    person1->set_name(person1_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person1->name() = " &lt;&lt; person1->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>    char person2_name[] = "Marcelle";<span></span></pre></td></tr><tr><td scope="row"><pre>    person2->set_name(person2_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person2->name() = " &lt;&lt; person2->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Destroy Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    delete person1;<span></span></pre></td></tr><tr><td scope="row"><pre>    delete person2;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001928-SW17" title="Listing 11Client using a C++ dynamically loaded library"></a><p class="codesample clear"><strong class="caption_number">Listing 11</strong>&nbsp;&nbsp;Client using a C++ dynamically loaded library</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Client.cpp */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;iostream><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cout;<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cerr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!lib_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the NewPerson function.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person_creator* NewPerson = (Person_creator*)dlsym(lib_handle, "NewPerson");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!NewPerson) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the NewPersonWithName function.<span></span></pre></td></tr><tr><td scope="row"><pre>    PersonWithName_creator* NewPersonWithName = (PersonWithName_creator*)dlsym(lib_handle, "NewPersonWithName");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!NewPersonWithName) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the DeletePerson function.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person_disposer* DeletePerson =<span></span></pre></td></tr><tr><td scope="row"><pre>        (Person_disposer*)dlsym(lib_handle, "DeletePerson");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!DeletePerson) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person* person1 = NewPerson();<span></span></pre></td></tr><tr><td scope="row"><pre>    char person_name[] = "Cendrine";<span></span></pre></td></tr><tr><td scope="row"><pre>    Person* person2 = NewPersonWithName(person_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person1->name() = " &lt;&lt; person1->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person2->name() = " &lt;&lt; person2->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    char person1_name[] = "Floriane";<span></span></pre></td></tr><tr><td scope="row"><pre>    person1->set_name(person1_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person1->name() = " &lt;&lt; person1->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>    char person2_name[] = "Marcelle";<span></span></pre></td></tr><tr><td scope="row"><pre>    person2->set_name(person2_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person2->name() = " &lt;&lt; person2->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Destroy Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    DeletePerson(person1);<span></span></pre></td></tr><tr><td scope="row"><pre>    DeletePerson(person2);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Close the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dlclose(lib_handle) != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40001928-SW23" title="Using Objective-C Classes"></a><h2 class="jump">Using Objective-C Classes</h2><p>To use an Objective-C class or category implemented in a dynamic library, a client should have an interface to the class or category. With knowledge of the class’s correct interface, the client can create instances of the class that are appropriately typed. Otherwise, the compiler produces warnings for methods with missing declarations.</p><p>The interfaces of Objective-C classes and categories are published in the library’s header files as protocols. Instantiating a class implemented in a dependent library is no different from doing the same for a locally defined class. However, when you load a dynamic library at runtime using <code><!--a target="_self" -->dlopen(3) OS X Developer Tools  Manual Page<!--/a--></code>, you must obtain the appropriate class by calling the <code><a href="https://developer.apple.com/reference/objectivec/1418952-objc_getclass" target="_self" class="urlLink">objc_getClass</a></code> function.</p><p>For example, <span class="content_text">Listing 12</span> contains the interfaces for the <code>Person</code> class and the <code>Titling</code> category to that class, which are implemented by the Person dynamic library.</p><a name="//apple_ref/doc/uid/TP40001928-SW18" title="Listing 12Interface to the Person class and its Titling category"></a><p class="codesample clear"><strong class="caption_number">Listing 12</strong>&nbsp;&nbsp;Interface to the <code>Person</code> class and its <code>Titling</code> category</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol Person<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setName:(NSString*)name;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString*)name;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Person : NSObject &lt;Person> {<span></span></pre></td></tr><tr><td scope="row"><pre>    @private<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString* _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* File: Titling.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol Titling<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setTitle:(NSString*)title;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Person (Titling) &lt;Titling><span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>A client compiled with these interfaces and linked with the Person library can create objects that implement the interfaces in a very straightforward way, as shown in <span class="content_text">Listing 13</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW19" title="Listing 13Example of a client that uses the Person library as a dependent library"></a><p class="codesample clear"><strong class="caption_number">Listing 13</strong>&nbsp;&nbsp;Example of a client that uses the Person library as a dependent library</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Client.m */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "Titling.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    @autoreleasepool {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Create an instance of Person.<span></span></pre></td></tr><tr><td scope="row"><pre>        Person&lt;Titling>* person = [[Person alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Use person.<span></span></pre></td></tr><tr><td scope="row"><pre>        [person setName:@"Perrine LeVan"];<span></span></pre></td></tr><tr><td scope="row"><pre>        [person setTitle:@"Ms."];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return(EXIT_SUCCESS);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the Person library is a runtime loaded library, however, the client must obtain a reference to the Person class from the Objective-C runtime after loading the library, using <code>objc_getClass</code>. It can then use that reference to instantiate a <code>Person</code> object. However, the variable that holds the instance must by typed as an <code>NSObject</code> that implements the <code>Person</code> and <code>Titling</code> protocols to avoid compiler warnings. When done, the client closes the library, as shown in <span class="content_text">Using Weakly Linked Symbols</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW24" title="Listing 14Example of a client that uses the Person library as a runtime loaded library"></a><p class="codesample clear"><strong class="caption_number">Listing 14</strong>&nbsp;&nbsp;Example of a client that uses the Person library as a runtime loaded library</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* File: Client.m */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;objc/runtime.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "Titling.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    @autoreleasepool {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Open the library.<span></span></pre></td></tr><tr><td scope="row"><pre>        void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!lib_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>            NSLog(@"[%s] main: Unable to open library: %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            __FILE__, dlerror());<span></span></pre></td></tr><tr><td scope="row"><pre>            exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Get the Person class (required with runtime-loaded libraries).<span></span></pre></td></tr><tr><td scope="row"><pre>        Class Person_class = objc_getClass("Person");<span></span></pre></td></tr><tr><td scope="row"><pre>        if (!Person_class) {<span></span></pre></td></tr><tr><td scope="row"><pre>            NSLog(@"[%s] main: Unable to get Person class", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>            exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Create an instance of Person.<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"[%s] main: Instantiating Person_class", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>        NSObject&lt;Person,Titling>* person = [[Person_class alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Use person.<span></span></pre></td></tr><tr><td scope="row"><pre>        [person setName:@"Perrine LeVan"];<span></span></pre></td></tr><tr><td scope="row"><pre>        [person setTitle:@"Ms."];<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Close the library.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (dlclose(lib_handle) != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            NSLog(@"[%s] Unable to close library: %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                __FILE__, dlerror());<span></span></pre></td></tr><tr><td scope="row"><pre>            exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return(EXIT_SUCCESS);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section><section><a name="//apple_ref/doc/uid/TP40001928-SW25" title="Getting Information About the Symbol at a Particular Address"></a><h2 class="jump">Getting Information About the Symbol at a Particular Address</h2><p>One of the dynamic loader compatibility (DLC) functions, <code><!--a target="_self" -->dladdr(3) OS X Developer Tools  Manual Page<!--/a--></code>, provides information on the image and nearest symbol that corresponds to an address. You can use this function to obtain information about the library that exports a particular symbol.</p><p>The information <code>dladdr</code> provides is returned through an output parameter of type <code>Dl_info</code>. These are the names of the structure’s fields as well as their descriptions:</p><ul class="ul"><li class="li"><p><code>dli_fname</code>: The pathname of the image</p></li><li class="li"><p><code>dli_fbase</code>: The base address of the image within the process</p></li><li class="li"><p><code>dli_sname</code>: The name of the symbol with an address that is equal to or lower than the address provided to <code>dladdr</code></p></li><li class="li"><p><code>dli_saddr</code>: The address of the symbol indicated by <code>dli_sname</code></p></li></ul><p><span class="content_text">Listing 15</span> shows how an image can get information about a symbol:</p><a name="//apple_ref/doc/uid/TP40001928-SW8" title="Listing 15Getting information about a symbol"></a><p class="codesample clear"><strong class="caption_number">Listing 15</strong>&nbsp;&nbsp;Getting information about a symbol</p><div class="codesample clear"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern char* dependencies();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Get information on dependencies().<span></span></pre></td></tr><tr><td scope="row"><pre>    Dl_info info;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dladdr(dependencies, &amp;info)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s] Info on dependencies():\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Pathname: %s\n",         __FILE__, info.dli_fname);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Base address: %p\n",     __FILE__, info.dli_fbase);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Nearest symbol: %s\n",   __FILE__, info.dli_sname);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Symbol address: %p\n",   __FILE__, info.dli_saddr);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s] Unable to find image containing the address %x\n",<span></span></pre></td></tr><tr><td scope="row"><pre>    __FILE__, &amp;dependencies);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='CreatingDynamicLibraries.html'>Next</a><a class='previousLink' rel='prev' href='DynamicLibraryDesignGuidelines.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2012 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2012-07-23</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1260/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/feedback.js"></script>
</body>
</html>
