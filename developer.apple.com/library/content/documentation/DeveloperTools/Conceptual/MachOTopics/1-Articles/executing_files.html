<!DOCTYPE html>
<html lang="en">
<head>
    <title>Executing Mach-O Files</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40001519">
    <meta id="document-version" name="document-version" content="3.3.1">
    <meta id="build" name="build" content="ded95564c405529dbbbe590063edd114" />
    <meta id="chapterId" name="chapterId" content="TP40001829">
    <meta id="date" name="date" content="2009-02-04">
    <meta id="description" name="description" content="Explains the use of the OS X runtime architecture, including program types, loading and executing code, and using libraries and plug-ins.">
    <meta id="book-title" name="book-title" content="Mach-O Programming Topics">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="Mac Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/mac">
    <meta id="reflib" name="reflib" content="Guides and Sample Code">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/General}">
    
    
    <meta id="copyright" name="copyright" content="Copyright 2017 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Mach-O Programming Topics: Executing Mach-O Files">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1260">
    <link id="book-index-page" rel="Start" title="Mach-O Programming Topics" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="loading_code.html">
    <link id="previous-page" rel="Prev" type="text/html" href="building_files.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1260/CSS/feedback.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta id="platforms" name="platforms" content="">
</head>    
<body><a name="//apple_ref/doc/uid/TP40001829" title="Executing Mach-O Files"></a>
    <div id="_omniture_top">
    <!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
    <script type="text/javascript">
    /* RSID: */
    var s_account="appleglobal,appleusdeveloper,dappdeveloperlib"
    </script>

    <script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
    <script type="text/javascript">
    s.pageName=AC.Tracking.pageName();
    s.channel="www.us.developer"

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)</script>
    <!-- End SiteCatalyst code version: H.8. -->
    </div>

    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode unified">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>Guides and Sample Code</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search Guides and Sample Code</label>
            
            
    
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Mach-O Programming Topics</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='loading_code.html'>Next</a><a class='previousLink' rel='prev' href='building_files.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/TP40001829-SW1" title="Executing Mach-O Files"></a><h1 id="pageTitle">Executing Mach-O Files</h1><p>To perform their objectives, programs must execute processes and link to dynamic shared libraries. To work with other libraries or modules, your application must define references to symbols in those modules; those references are resolved at runtime. At runtime the symbol names of all the modules your application uses live in a shared namespace, similar to a directory. To allow for future enhancements to applications as well as the libraries they use, application and library developers must ensure the names they choose for their functions and data do not conflict with the names used in other modules.</p><p>The two-level namespace feature of OS X v10.1 and later adds the module name as part of the symbol name of the symbols defined within it. This approach ensures a module’s symbol names don’t conflict with the names used in other modules. To perform special tasks or to provide an enhanced user experience, your application may need to launch other applications or create processes to run command-line tools. To maintain a high degree of interoperability and provide a consistent user experience, your applications should use specific system functions and frameworks to execute processes and launch applications.</p><p>This article provides an overview of the OS X dynamic loading process. The process of loading and linking a program in OS X mainly involves two entities: the OS X kernel and the dynamic linker<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_21"></a><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_22"></a>. When you execute a program, the kernel creates a process for the program, and loads the program and the dynamic linker shared library, usually <code>/usr/lib/dyld</code>, in the program’s address space. The kernel then executes code in the dynamic linker that loads the libraries the program references. This article also describes the visibility symbols in a module get depending on how they are defined and the process of resolving symbol references at runtime.</p><section><a name="//apple_ref/doc/uid/TP40001829-98172" title="Launching an Application"></a><a name="//apple_ref/doc/uid/TP40001829-98172-TPXREF108" title="Launching an Application"></a><h2 class="jump">Launching an Application</h2><p>When you launch an application from the Finder or the Dock, or when you run a program in a shell, the system ultimately calls two functions on your behalf, <code><!--a-->fork<!--/a--></code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_23"></a> and <code><!--a-->execve<!--/a--></code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_24"></a>. The <code>fork</code> function creates a process; the <code>execve</code> function loads and executes the program. There are several variant exec functions, such as <code><!--a-->execl<!--/a--></code>, <code><!--a-->execv<!--/a--></code>, and <code><!--a-->exect<!--/a--></code>, each providing a slightly different way of passing arguments and environment variables to the program. In OS X, each of these other exec routines eventually calls the kernel routine <code><!--a-->execve<!--/a--></code>.</p><p>When writing a Mac app, you should use the Launch Services framework to launch other applications. Launch Services understands application packages, and you can use it to open both applications and documents. The Finder and the Dock use Launch Services to maintain the database of mappings from document types to the applications that can open them. Cocoa<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_25"></a> applications can use the class <code>NSWorkspace</code> to launch applications and documents; <code>NSWorkspace</code> itself uses Launch Services. Launch Services ultimately calls <code><!--a-->fork<!--/a--></code> and <code><!--a-->execve<!--/a--></code> to do the actual work of creating and executing the new process. For more information on Launch Services, see <em><a href="../../../../Carbon/Conceptual/LaunchServicesConcepts/LSCIntro/LSCIntro.html#//apple_ref/doc/uid/TP30000999" data-renderer-version="1" target="_self">Launch Services Programming Guide</a></em>.</p></section><section><a name="//apple_ref/doc/uid/TP40001829-96913" title="Forking and Executing the Process"></a><a name="//apple_ref/doc/uid/TP40001829-96913-TPXREF103" title="Forking and Executing the Process"></a><h2 class="jump">Forking and Executing the Process</h2><p>To create a process using BSD system calls, your process must call the <code><!--a-->fork<!--/a--></code> system call. The <code><!--a-->fork<!--/a--></code> call creates a logical copy of your process, then returns the ID of the new process to your process. Both the original process and the new process continue executing from the call to <code>fork</code>; the only difference is that <code>fork</code> returns the ID of the new process to the original process and zero to the new process. (The <code><!--a-->fork<!--/a--></code> function returns <code>-1</code> to the original process and sets <code>errno</code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_26"></a> to a specific error value if the new process could not be created.)</p><p>To run a different executable, your process must call the <code><!--a-->execve<!--/a--></code> system call with a pathname specifying the location of the alternate executable. The <code><!--a-->execve<!--/a--></code> call replaces the program currently in memory with a different executable file.</p><p>A Mach-O executable file contains a header consisting of a set of load commands<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_27"></a>. For programs that use shared libraries or frameworks, one of these commands specifies the location of the linker to be used to load the program. If you use Xcode, this is always <code>/usr/lib/dyld</code>, the standard OS X dynamic linker<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_28"></a>.</p><p>When you call the <code>execve</code> routine, the kernel first loads the specified program file and examines the <code>mach_header</code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_29"></a> structure at the start of the file. The kernel verifies that the file appear to be a valid Mach-O file and interprets the load commands stored in the header. The kernel then loads the dynamic linker specified by the load commands into memory and executes the dynamic linker on the program file.</p><p>The dynamic linker loads all the shared libraries that the main program links against (the <a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_30"></a><em class="newTerm">dependent libraries</em>) and binds enough of the symbols to start the program. It then calls the entry point function. At build time, the static linker adds the standard entry point function to the main executable file from the object file <a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_31"></a><code>/usr/lib/crt1.o</code>. This function sets up the runtime environment state for the kernel and calls static initializers for C++ objects, initializes the Objective-C runtime, and then calls the program’s <code>main</code> function<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_32"></a>.</p></section><section><a name="//apple_ref/doc/uid/TP40001829-97021" title="Finding Imported Symbols"></a><a name="//apple_ref/doc/uid/TP40001829-97021-TPXREF121" title="Finding Imported Symbols"></a><h2 class="jump">Finding Imported Symbols</h2><p>When the dynamic linker loads a Mach-O file (which, for the purposes of this section, is called the <em class="newTerm">client program</em>), it connects the file’s imported symbols to their definitions in a shared library or framework. This section describes the process of binding the imported symbols in one Mach-O file to their definitions in other Mach-O files. It also explains the process of finding a symbol. See also <span class="content_text"><a href="loading_code.html#//apple_ref/doc/uid/TP40001830-97384" data-renderer-version="1">Loading Plug-in Code With Bundles</a></span> in <span class="content_text"><a href="loading_code.html#//apple_ref/doc/uid/TP40001830-SW1" data-renderer-version="1" target="_self">Loading Code at Runtime</a></span> for information on finding symbols in plug-ins.</p><section><a name="//apple_ref/doc/uid/TP40001829-97047" title="Binding Symbols"></a><a name="//apple_ref/doc/uid/TP40001829-97047-TPXREF111" title="Binding Symbols"></a><h3 class="jump">Binding Symbols</h3><p><em class="newTerm">Binding</em><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_33"></a> is the process of resolving a module’s references to functions and data in other modules (the <em class="newTerm">undefined external symbols</em>, sometimes called <em class="newTerm">imported symbols</em>). The modules may be in the same Mach-O file or in different Mach-O files; the semantics are identical in either case. When the application is first loaded, the dynamic linker loads the imported shared libraries into the address space of the program. When binding is performed, the linker replaces each of the program’s imported references with the address of the actual definition from one of the shared libraries.</p><p>The dynamic linker can bind a program at several stages during loading and execution, depending on the options you specify at build time:</p><ul class="ul"><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_34"></a><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_35"></a><p>With <em class="newTerm">just-in-time binding</em> (also called lazy binding), the dynamic linker binds a reference (and all the other references in the same module) when the program first uses the reference. The dynamic linker loads the shared libraries the client program depends on when the program is loaded. However, the dynamic linker doesn’t bind the program’s references to symbols within the shared libraries until the symbols are used.</p></li><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_36"></a><p>With <em class="newTerm">load-time binding</em>, the dynamic linker binds all the imported references immediately upon loading the program, or, for bundles, upon loading the bundle. To use load-time binding with the standard tools, specify the<code> -bind_at_load</code> option to <code>ld</code> to indicate that the dynamic linker must immediately bind all external references when the file is loaded. Without this option, <code>ld</code> sets up the output file for just-in-time binding.</p></li><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_37"></a><p>With <em class="newTerm">prebinding</em>, a form of load-time binding, the shared libraries referenced by the program are each prebound at a specified address. The static linker sets the address of each undefined reference in the program to default to these addresses. At runtime, the dynamic linker needs only to verify that none of the addresses have changed since the program was built (or since the prebinding was recomputed). If the addresses have changed, the dynamic linker must undo the prebinding by clearing the prebound addresses for all the undefined references and then proceed as if the program had been just-in-time bound. Otherwise, it does not need to perform any action to bind the program.</p><p>Prebinding requires that each framework specify its desired base virtual memory address and that none of the prebound addresses of the loaded frameworks overlap. To prebind a file with the standard tools, specify the <code>-prebind</code> option to <code>ld</code>.</p></li><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_38"></a><p><em class="newTerm">Weak references</em>, a feature introduced in OS X v10.2, is useful for selectively implementing features that may be available on some systems, but not on others. This mode of binding allows a program to optionally bind to specified shared libraries. If the dynamic linker cannot find definitions for weak references, it sets them to <code>NULL</code> and continues to load the program. The program can check at runtime to find out whether or not a reference is null and, if so, avoid using the reference. You can specify both libraries and individual symbols to be weakly referenced.</p></li></ul><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40001829-SW2" title="Note"></a><p><strong>Note:</strong>&nbsp;The OS X weak linking design is derived from the classic Mac OS Code Fragment Manager implementation of weak linking. If you are familiar with the ELF executable format, you may be used to a different meaning for the terms <em>weak symbol</em> or <em>weak linking</em>, where a weak symbol may be overridden by a non-weak symbol. The equivalent OS X feature is the <em>weak definition</em>—see <span class="content_text"><a href="#//apple_ref/doc/uid/TP40001829-98432" data-renderer-version="1">Scope and Treatment of Symbol Definitions</a></span> for more information</p><p></p></aside></div><p>If no other type of binding is specified for a given library, the static linker sets up the program’s undefined references to that library to use just-in-time binding.</p></section><section><a name="//apple_ref/doc/uid/TP40001829-97182" title="Searching for Symbols"></a><a name="//apple_ref/doc/uid/TP40001829-97182-TPXREF112" title="Searching for Symbols"></a><h3 class="jump">Searching for Symbols</h3><p>A <em class="newTerm">symbol</em><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_39"></a> is a generic representation of the location of a function, data variable, or constant in an executable file. References to functions and data in a program are references to symbols. To refer to a symbol when using the dynamic linking routines, you usually pass the name of the symbol, although some functions also accept a number representing the ordering of the symbol in the executable file. The name of a symbol representing a function that conforms to standard C calling conventions is the name of the function with an underscore prefix. Thus, the name of the symbol representing the function <code>main</code> would be <code>_main</code>.</p><p>Programs created by the OS X v10.0 development tools add all symbols from all loaded shared libraries into a single global list. Any symbol that your program references can be located in any shared library, as long as that shared library is one of the program’s dependent libraries (or one of the dependent libraries of the dependent libraries).</p><p>OS X v10.1 introduced the two-level symbol namespace<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_40"></a> feature. The first level of the two-level namespace is the name of the library that contains the symbol, and the second is the name of the symbol. With the two-level namespace feature enabled, when the static linker records references to imported symbols, it records a reference to the name of the library that contains the symbol and the name of the symbol<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_41"></a>. Linking your programs with the two level namespace feature offers two benefits over the flat namespace:</p><ul class="ul"><li class="li"><p><em class="newTerm">Enhanced performance when searching for symbols.</em> With the two-level namespace, the dynamic linker knows exactly where to start looking for the implementation of a symbol. With a flat namespace, the dynamic linker must search all the loaded libraries for the one that contains the symbol.</p></li><li class="li"><p><em class="newTerm">Enhanced forward compatibility.</em> In the flat namespace, two or more libraries cannot contain symbols with different implementations that share the same name because the dynamic linker cannot know which library contains the preferred implementation. This is not initially a problem, because the static linker catches any such problems when you first build the application. However, if the vendor of one of your dependent shared libraries later releases a new version of the library that contains a symbol with the same name as one in your program or in another dependent shared library, your program will fail to run.</p></li></ul><p>Your application must link directly to the shared library that contains the symbol (or, if the library is part of an umbrella framework, to the umbrella framework that contains it).</p><p>When obtaining symbols in a program built with the two-level namespace feature enabled, you must specify a reference to the shared library that contains the symbols.</p><p>By default, the static linker in OS X v10.1 and later uses a two-level namespace for all Mach-O files.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40001829-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;The OS X two-level namespace feature is loosely based on the design of the Code Fragment Manager’s namespace. A two-level namespace is approximately equivalent to the namespace used to look up symbols in code fragments. Because Code Fragment Manager always requires an explicit reference to the library in which a symbol should be found, there is no Code Fragment Manager equivalent to a flat namespace search.</p><p></p></aside></div><p>For programs that do not have a two-level namespace<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_42"></a>, you can tell the linker to define references to undefined symbols even if the linker cannot find the library that contains them. When you build an executable with such undefined symbols, you are making the assumption that one of the other files loaded as part of the executable file at runtime contains those symbols. Bundles and shared libraries sometimes use this option to reference symbols defined in the main executable. However, this causes you to lose the performance and compatibility benefits of two-level namespaces. It’s usually better to explicitly link against an executable that defines the references. However, if you must link with undefined references, you can do it by enabling the flat namespace feature and suppressing undefined reference warnings, using the options <code>-flat_namespace</code> and <code>-undefined suppress</code> as in the following command line:</p><div class="codesample clear"><table><tr><td scope="row"><pre>ld -o my_tool -flat_namespace -undefined suppress peace.o love.o<span></span></pre></td></tr></table></div><p>When building executables with a two-level namespace, you can allow the remaining undefined symbols to be looked up by the dynamic linker if the program is targeted for OS X v10.3 and later (the <code>MACOSX_DEPLOYMENT_TARGET</code> environment variable is set to <code>10.3</code> or higher). To take advantage of this feature, use the <code>-undefined dynamic_lookup</code> option.</p><p>To build executables with a two-level namespace, the static linker must be able to find the source library for each symbol. This can present difficulties for authors of bundles and dynamic shared libraries that assume a flat, global symbol namespace. To build successfully with the two-level namespace, keep the following points in mind:</p><ul class="ul"><li class="li"><p>Bundles that need to reference symbols defined in the program’s main executable must use the <code>-bundle_loader</code> static linker option. The static linker can then search the main executable for the undefined symbols.</p></li><li class="li"><p>Shared libraries that need to reference symbols defined in the program’s main executable must load the symbol dynamically using a function that does not require a library reference, such as <code>dlsym</code> or <code><!--a target="_self" -->NSLookupSymbolInImage<!--/a--></code> (<em><!--a target="_self" -->OS X ABI Dynamic Loader Reference<!--/a--></em>).</p></li></ul><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40001829-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp;A two-level symbol namespace can be searched using functions for doing flat symbol searches.</p><p></p></aside></div></section></section><section><a name="//apple_ref/doc/uid/TP40001829-98432" title="Scope and Treatment of Symbol Definitions"></a><a name="//apple_ref/doc/uid/TP40001829-98432-TPXREF120" title="Scope and Treatment of Symbol Definitions"></a><h2 class="jump">Scope and Treatment of Symbol Definitions</h2><p>Symbols in an object file may exist at several levels of scope. This section describes each of the possible scopes that a symbol may be defined at, and provides samples of C code used to create each symbol type. These samples work with the standard developer tools; a third party tool set may have different conventions.</p><p>A <em class="newTerm">defined external symbol</em> is any symbol defined in the current object file, including functions and data. The following C code defines external symbols:</p><div class="codesample clear"><table><tr><td scope="row"><pre>int x = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>double y = 99 __attribute__((visibility("default")));   // GCC 4.0 only<span></span></pre></td></tr></table></div><p>An <em class="newTerm">undefined external symbol</em><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_43"></a> is any symbol defined in a file outside of the current file. The following C code defines two external symbols, a variable and a function:</p><div class="codesample clear"><table><tr><td scope="row"><pre>extern int x;<span></span></pre></td></tr><tr><td scope="row"><pre>extern void SomeFunction(void);<span></span></pre></td></tr></table></div><p>A <em class="newTerm">common symbol</em><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_44"></a> is a symbol that may appear in multiple intermediate object files. The static linker permits multiple common symbol definitions with the same name in input files, and copies the one with the largest size to the final product. If there is another symbol with the same name as a common symbol, the static linker ignores the common symbol instead.</p><p>The standard C compiler generates a common symbol when it sees a <em class="newTerm">tentative definition</em>—a global variable that has no initializer and is not marked <code>extern</code>. The following line is an example of a tentative definition:</p><div class="codesample clear"><table><tr><td scope="row"><pre>int x;<span></span></pre></td></tr></table></div><p>A multi-module shared library, which <code>ld</code> builds by default, cannot have common symbols. However, you can build a shared library as a single module with the <code>-single_module</code> flag. To eliminate common symbols in an existing shared library, you must either explicitly define the symbol (with an initialized value, for example) in one of the modules in the shared library, or pass the <code>-fno-common</code> flag to the compiler.</p><p>A <em class="newTerm">private defined symbol</em><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_45"></a> is a symbol that is not visible to other modules. The following C code defines a private symbol:</p><div class="codesample clear"><table><tr><td scope="row"><pre>static int x;<span></span></pre></td></tr></table></div><p>A <em class="newTerm">private external symbol</em> is a defined external symbol that is visible only to other modules within the same object file as the module that contains it. The standard static linker changes private external symbols into private defined symbols unless you specify otherwise (using the <code>-keep_private_externs</code> flag).</p><p>You can mark a symbol as private external by using the <code>__private_extern__</code> keyword (which works only in C) or the <code>visibility("hidden")</code> attribute (which works both in C and C++ with GCC 4.0), as in this example:</p><div class="codesample clear"><table><tr><td scope="row"><pre>__private_extern__ int x = 0;                       // C only<span></span></pre></td></tr><tr><td scope="row"><pre>int y = 99 __attribute__((visibility("hidden")));   // C and C++, GCC 4.0 only<span></span></pre></td></tr></table></div><p>A <em class="newTerm">coalesced symbol</em><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_46"></a> is a symbol that may be defined in multiple object files but that the static linker generates only one copy of in the output file. This can save a lot of memory with certain C++ language features that the compiler must generate for each individual object file, such as virtual function tables, runtime type information (RTTI), and C++ template instantiations. The compiler determines which constructs should be coalesced; no work on your part is required.</p><p>A <em class="newTerm">weak reference</em> is an undefined external symbol that need not be found in order for the client program to successfully link. If the symbol does not exist, the dynamic linker sets the address of the symbol to zero. Files with weak references can be used only in OS X v10.2 and later. The following C code demonstrates conditionalizing an API call using a weak reference:</p><div class="codesample clear"><table><tr><td scope="row"><pre>/* Only call this API if it exists */<span></span></pre></td></tr><tr><td scope="row"><pre>if ( SomeNewFunction != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>        SomeNewFunction();<span></span></pre></td></tr></table></div><p>To specify that a function should be treated as a weak reference, use the <code>weak_import</code> attribute on a function prototype, as demonstrated by the following code:</p><div class="codesample clear"><table><tr><td scope="row"><pre>void SomeNewFunction(void) __attribute__((weak_import));<span></span></pre></td></tr></table></div><p>A <em class="newTerm">coalesced weak reference</em> is an undefined external reference to a symbol defined in multiple object files. In OS X v10.4 and later (with GCC 4.0 and later), you can specify that a symbol be made into a coalesced weak reference by adding the weak attribute to the symbol’s declaration. For example: </p><div class="codesample clear"><table><tr><td scope="row"><pre>void SomeNewFunction(void) __attribute__((weak));<span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40001829-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;Programmers who use other operating systems may be familiar with the concept of symbols that are marked with a COMDAT flag; a coalesced symbol is the OS X equivalent feature.</p><p></p></aside></div><p>A <em class="newTerm">weak definition</em> is a symbol that is ignored by the linker if an otherwise identical but nowness definition exists. This is used by the standard C++ compiler to support C++ template instantiations. The compiler marks implicit—and not explicit—template instantiations as weak definitions. The static linker then prefers any explicit template instantiation to an implicit one for the same symbol, which provides correct C++ linking semantics. As with coalesced symbols, the compiler determines the constructs that require the weak definitions feature; no work on your part is required.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40001829-SW6" title="Note"></a><p><strong>Note:</strong>&nbsp;Files with weak definitions can be used only in OS X v10.2 and later. The static linker changes any weak definitions into nowness definitions, so this is only a concern for intermediate object files and static libraries that you wish to deploy on earlier versions of OS X.</p><p></p></aside></div><p>A <em class="newTerm">debugging symbol</em> is a symbol generated by the compiler that allows the debugger to map from addresses in machine code to locations in source code. The standard compilers generate debugging symbols using either the Stabs format or the DWARF format (supported in Xcode 2.4 and later). When using the Stabs format, debugging symbols, like other symbols, are stored in the symbol table (see <em><!--a target="_self" -->OS X ABI Mach-O File Format Reference<!--/a--></em>). But with the DWARF format, debugging symbols are stored in a specialized segment: the <code>__DWARF</code> segment. With DWARF you also have the option of storing debugging symbols in a separate debug-information file, which reduces the size of the binary files while permitting a full debugging experience when the corresponding debug-information files are available.</p></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='loading_code.html'>Next</a><a class='previousLink' rel='prev' href='building_files.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2009-02-04</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1260/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1260/JavaScript/feedback.js"></script>
</body>
</html>
